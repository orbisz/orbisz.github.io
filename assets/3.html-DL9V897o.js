import{_ as s,c as a,a as e,o as i}from"./app-ByLG9LQz.js";const l="/assets/img_35-CkJ-xmpd.png",t="/assets/img_20-C5KJKesk.png",p="/assets/img_21-pV5BTCv8.png",c="/assets/img_22-N91p_XBQ.png",o={};function u(r,n){return i(),a("div",null,n[0]||(n[0]=[e(`<h3 id="难点及解决" tabindex="-1"><a class="header-anchor" href="#难点及解决"><span>难点及解决</span></a></h3><h4 id="系统设计与架构挑战" tabindex="-1"><a class="header-anchor" href="#系统设计与架构挑战"><span>系统设计与架构挑战</span></a></h4><ol><li>Agent 执行链路复杂性 <ul><li>需支持固定流程、循环调用、动态决策等多种执行模式，逻辑分支复杂。</li><li>多 Agent 协作时，任务依赖和错误传播难以管理。</li></ul></li><li>动态实例化与依赖注入 <ul><li>根据用户配置动态加载 AI 客户端、模型、工具链等组件，组件间的依赖关系管理复杂，需解决 Spring 容器生命周期管理问题。</li></ul></li><li>多模型框架兼容性 <ul><li>需要同时支持 OpenAI、DeepSeek 等不同大模型，但各模型 API 协议差异大。</li><li>Spring AI 框架早期版本对部分模型（如 DeepSeek）支持不完善。</li></ul></li><li>流式处理与上下文管理 <ul><li>实现流式响应时，需处理长连接下的上下文同步问题（如用户追问时传递历史对话）。</li><li>服务端流式接口（SSE）与客户端（如 JavaScript EventSource）的兼容性调试。</li></ul></li><li>多数据源管理 <ul><li>需同时操作 PostgreSQL（向量库）、MySQL（业务库）等异构数据库。</li><li>数据库事务一致性难以保证（如向量库写入与业务数据更新的原子性）。</li></ul></li></ol><p><strong>解决方案</strong></p><p>通过以下核心策略攻克难点：</p><ol><li><p>模块化设计：将复杂流程拆解为独立节点（如 MCP 工具、RAG 顾问），通过责任链模式组合。</p></li><li><p>设计模式优化：采用多种设计模式，对执行流程进行解耦和实现。</p></li><li><p>Spring 生态深度整合：利用 Spring AI、Spring Boot Actuator、Spring Cloud 等组件简化开发。</p></li><li><p>动态bean配置：通过AbstractArmorySupport提供Bean动态注册能力 ，使用DynamicContext在节点间传递数据，避免重复查询</p></li><li><p>异步与流式处理：通过 Reactor 框架（Flux/Mono）和 SSE 实现高并发下的实时交互。</p></li><li><p>动态化配置：支持数据库动态加载 Agent 配置，实现“零代码”扩展。</p></li><li><p>规则树与责任链模式</p><ul><li>将执行流程抽象为节点（如 MCPToolsAnalysisNode、PlanningNode），通过责任链模式串联：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">public class Step1McpToolsAnalysisNode extends AbstractArmorySupport {</span>
<span class="line">@Override</span>
<span class="line">public DynamicContext apply(DynamicContext context) {</span>
<span class="line">// 工具分析逻辑</span>
<span class="line">return nextChain.apply(context); // 传递到下一节点</span>
<span class="line">}</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>支持动态插入新节点，扩展执行策略。</li></ul></li><li><p>动态 Bean 注册</p><ul><li>利用 Spring 的 BeanDefinitionRegistry 动态注册客户端、模型等组件：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) applicationContext.getAutowireCapableBeanFactory();</span>
<span class="line">BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(OpenAiApi.class);</span>
<span class="line">builder.addPropertyValue(&quot;baseUrl&quot;, &quot;https://api.deepseek.com&quot;);</span>
<span class="line">beanFactory.registerBeanDefinition(&quot;deepSeekApi&quot;, builder.getBeanDefinition());</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>统一抽象层设计</p><ul><li>通过 Spring AI 的 ToolCallbackProvider 和 MCP 框架，将不同模型的调用统一为标准化接口。例如：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">@Autowired</span>
<span class="line">private ToolCallbackProvider tools; // 统一注入所有工具（含不同模型）</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用 one-api 网关屏蔽模型差异，实现跨模型调用。</li></ul></li><li><p>上下文传递机制</p><ul><li>前端：利用 localStorage 存储对话历史（如 localStorage.setItem(&#39;chatHistory&#39;, JSON.stringify(history))）。</li><li>后端：通过 CHAT_MEMORY_CONVERSATION_ID_KEY 参数绑定对话 ID，结合 Spring AI 的 MessageWindowChatMemory 实现会话记忆：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">chatClient.prompt(message)</span>
<span class="line">.advisors(a -&gt; a.param(CHAT_MEMORY_CONVERSATION_ID_KEY, &quot;chatId-101&quot;))</span>
<span class="line">.call().content();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>与MessageChatMemoryAdvisor配合，自动将历史消息注入Prompt，确保模型生成时能基于完整上下文响应</li></ul></li><li><p>多数据源架构</p><ul><li>使用 Spring 的 @Primary 和 @Qualifier 注解区分数据源，配置多数据源连接池（如 Hikari）：</li><li>通过 AbstractRoutingDataSource 动态切换数据源，确保事务隔离。</li></ul></li></ol><h4 id="分布式与高可用挑战" tabindex="-1"><a class="header-anchor" href="#分布式与高可用挑战"><span>分布式与高可用挑战</span></a></h4><ol><li>服务熔断与降级 <ul><li>大模型调用不稳定时，需快速降级为本地缓存或备用模型。</li><li>高并发下 Redis 缓存穿透和雪崩问题。</li></ul></li><li>跨服务通信 <ul><li>Agent 调用链涉及多个微服务（如日志分析、监控告警），需保证通信可靠性。</li></ul></li><li>API 安全防护 <ul><li>防止恶意用户通过 Agent 接口发起攻击（如 Prompt 注入）。</li><li>跨域请求（CORS）导致的安全漏洞。</li></ul></li><li>日志与监控 <ul><li>Agent 执行链路长，日志分散，故障排查困难。</li><li>需要实时监控 Agent 任务执行状态（如成功率、耗时）。</li></ul></li></ol><p><strong>解决方案</strong> 5. 熔断机制</p><ul><li>使用 Spring Cloud Circuit Breaker 对模型调用进行熔断：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">@Bean</span>
<span class="line">public CircuitBreakerRegistry circuitBreakerRegistry() {</span>
<span class="line">return CircuitBreakerRegistry.ofDefaults();</span>
<span class="line">}</span>
<span class="line">// 调用时添加熔断保护</span>
<span class="line">circuitBreaker.run(() -&gt; chatClient.prompt(message).call().content(), throwable -&gt; &quot;Fallback Answer&quot;);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>缓存策略优化 <ul><li>对高频查询的知识库采用 Redis 集群，并设置 TTL 和随机过期时间防雪崩：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">@Cacheable(value = &quot;knowledgeCache&quot;, key = &quot;#tag&quot;, unless = &quot;#result == null&quot;)</span>
<span class="line">public List&lt;Document&gt; getKnowledgeByTag(String tag) { ... }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li>安全加固 <ul><li>对用户输入进行 XSS 过滤和长度限制：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">@InitBinder</span>
<span class="line">public void initBinder(WebDataBinder binder) {</span>
<span class="line">binder.setValidator(new InputValidator()); // 自定义输入校验</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>配置 CORS 白名单：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">spring:</span>
<span class="line">cors:</span>
<span class="line">allowed-origins: &quot;https://example.com&quot;</span>
<span class="line">allowed-methods: GET,POST</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>日志与监控体系 <ul><li>集成 ELK（Elasticsearch + Logstash + Kibana）实现日志集中分析：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">input {</span>
<span class="line">file {</span>
<span class="line">path =&gt; &quot;/var/log/agent/*.log&quot;</span>
<span class="line">codec =&gt; json</span>
<span class="line">}</span>
<span class="line">}</span>
<span class="line">output {</span>
<span class="line">elasticsearch {</span>
<span class="line">hosts =&gt; [&quot;elasticsearch:9200&quot;]</span>
<span class="line">}</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用 Prometheus + Grafana 监控 Agent 任务指标：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line"># Prometheus 配置</span>
<span class="line">- job_name: &#39;agent_tasks&#39;</span>
<span class="line">  static_configs:</span>
<span class="line">   - targets: [&#39;agent-service:8080&#39;]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>用户体验增强 <ul><li>流式优化：通过 publishOn(Schedulers.boundedElastic()) 避免阻塞主线程，减少首字延迟。</li><li>意图纠偏：在 RAG 检索阶段引入意图分类模型，过滤无关文档：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">// 检索时附加意图标签</span>
<span class="line">SearchRequest searchRequest = SearchRequest.builder()</span>
<span class="line">.query(message)</span>
<span class="line">.filterExpression(&quot;intent == &#39;technical_support&#39;&quot;)</span>
<span class="line">.build();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>性能优化策略 <ul><li>RAG 向量化：采用 CustomTextSplitter 自定义分片策略，结合异步向量写入：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">CompletableFuture.runAsync(() -&gt; vectorStore.accept(documentSplitterList));</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>流式接口限流：使用 Resilience4j 的 RateLimiter 限制并发流式请求：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">@RateLimiter(name = &quot;chatStreamLimiter&quot;, fallbackMethod = &quot;fallback&quot;)</span>
<span class="line">public Flux&lt;ChatResponse&gt; chatStream(...) { ... }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h4 id="one-api详解" tabindex="-1"><a class="header-anchor" href="#one-api详解"><span>one-api详解</span></a></h4><p>ne-api 作为 “中间代理网关”，通过 “统一入口接收请求 → 内部适配模型差异 → 统一格式返回结果” 的逻辑，彻底屏蔽了不同 AI 模型的接口、参数、认证差异，让开发者 / 应用能 “用一套代码，调用所有模型”。</p><p>实现流程：</p><ol><li>第一步：one-api 提供 “统一的调用入口”： 不管底层对接了多少个模型（OpenAI、通义千问、Claude 等），one-api 对外只暴露 一套标准化接口（默认兼容 OpenAI 的接口格式，因为 OpenAI 接口是行业事实标准）。比如：用户调用任何模型，都只用发请求到 one-api 地址/v1/chat/completions，参数格式也完全遵循 OpenAI 的规范（如 model 指定模型名、messages 传对话历史）。</li><li>第二步：one-api 内部做 “差异适配与协议转换”： 这是 one-api 屏蔽差异的核心环节 —— 当 one-api 收到用户请求后，会自动完成 3 件事，把 “统一请求” 转换成 “底层模型能识别的请求”： <ul><li>模型路由：根据用户请求中 model 参数的值（比如用户传 model: &quot;qwen-plus&quot;），one-api 会匹配到已配置的 “通义千问” 模型（管理员提前在 one-api 后台配置了 qwen-plus 对应通义千问的真实模型标识）。</li><li>参数映射：把用户传的 “OpenAI 格式参数” 转换成底层模型的参数格式。 例：用户传 model: &quot;qwen-plus&quot;，one-api 自动转换成通义千问需要的 model_id: &quot;qwen-plus&quot;；用户传 messages: [{role: &quot;user&quot;, content: &quot;你好&quot;}]，one-api 自动转换成通义千问要求的 messages: [{role: &quot;user&quot;, content: &quot;你好&quot;}]（若格式有差异则自动调整）。</li><li>认证注入：管理员提前在 one-api 后台为每个模型配置了对应的 API 密钥（如 OpenAI 的 Key、通义千问的 Key），one-api 会自动在请求头中注入该模型的认证信息（比如给通义千问加 X-API-Key，给 OpenAI 加 Authorization: Bearer），用户无需关心密钥管理。</li></ul></li><li>第三步：one-api 统一 “返回结果格式” 底层模型返回结果后，one-api 会把 “模型原生格式的结果” 转换成 统一的 OpenAI 格式 回传给用户。</li></ol><h3 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h3><h4 id="系统架构图" tabindex="-1"><a class="header-anchor" href="#系统架构图"><span>系统架构图</span></a></h4><h5 id="系统-api-设计架构" tabindex="-1"><a class="header-anchor" href="#系统-api-设计架构"><span>系统 API 设计架构</span></a></h5><p><img src="`+l+`" alt="img_35.png"></p><h4 id="项目中规则树的体现" tabindex="-1"><a class="header-anchor" href="#项目中规则树的体现"><span>项目中规则树的体现</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">public class AiAgentEngineStarterEntity {</span>
<span class="line"></span>
<span class="line">    /**</span>
<span class="line">     * 客户端ID列表</span>
<span class="line">     * </span>
<span class="line">     * 需要预热的AI客户端ID集合，这些客户端在引擎启动时</span>
<span class="line">     * 被初始化并装配相应的AI模型、工具链和顾问组件</span>
<span class="line">     */</span>
<span class="line">    private List&lt;Long&gt; clientIdList;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么是client_id</strong></p><p>因为client代表一个完整的AI智能体客户端配置单元，通过它可以关联查询到客户端的所有配置组件。 <img src="`+t+'" alt="img_20.png"></p><p>通过id获取所有配置 <img src="'+p+'" alt="img_21.png"></p><p><strong>DefaultArmoryStrategyFactory.DynamicContext - 动态上下⽂</strong></p><p>动态上下⽂在 RootNode 节点中加载，所有数据都被⼀次性加载并存储到 DynamicContext 中，并且这里是并发加载，提升了性能。后续节点都可以从参数直接获取，不⽤从数据库中找了! 通过泛型方法setValue和getValue，实现了类型安全的数据存取，避免了频繁的类型转换。</p><p><strong>AI-Agent装配流程图</strong><img src="'+c+`" alt="img_22.png"></p><h4 id="promptchatmemoryadvisor" tabindex="-1"><a class="header-anchor" href="#promptchatmemoryadvisor"><span>PromptChatMemoryAdvisor</span></a></h4><p>Spring AI实现的提示词记忆顾问</p><ul><li>自动维护历史对话记录</li><li>在每次请求的时候将相关的历史消息自动注入到提示词中</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 项目中的实际使用</span></span>
<span class="line"><span class="token class-name">ChatClient</span> chatClient <span class="token operator">=</span> <span class="token class-name">ChatClient</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>chatModel<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">defaultAdvisors</span><span class="token punctuation">(</span></span>
<span class="line">        <span class="token comment">// 添加记忆顾问</span></span>
<span class="line">        <span class="token keyword">new</span> <span class="token class-name">PromptChatMemoryAdvisor</span><span class="token punctuation">(</span><span class="token class-name">MessageWindowChatMemory</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token function">maxMessages</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment">// 最多记住10条消息</span></span>
<span class="line">            <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 调用时指定会话ID</span></span>
<span class="line"><span class="token class-name">String</span> response <span class="token operator">=</span> chatClient</span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">&quot;你好，我是张三&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">advisors</span><span class="token punctuation">(</span>a <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token constant">CHAT_MEMORY_CONVERSATION_ID_KEY</span><span class="token punctuation">,</span> <span class="token string">&quot;user_123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MessageWindowChatMemory是消息窗口记忆的实现, 通过滑动窗口的形式保存maxMessages条消息。</p><h4 id="ragansweradvisor" tabindex="-1"><a class="header-anchor" href="#ragansweradvisor"><span>RagAnswerAdvisor</span></a></h4><p>自定义的RAG顾问实现。这个方法是核心的从向量数据库中获取到和提问相关的documents, 然后由此注入上下文参数, 构建一个新的增强请求</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">adviseContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 1. 构建增强提示词</span></span>
<span class="line">    <span class="token class-name">String</span> advisedUserText <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">userText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">lineSeparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userTextAdvise<span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 2. 渲染查询模板</span></span>
<span class="line">    <span class="token class-name">String</span> query <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromptTemplate</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">userText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">userParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 3. 执行向量检索</span></span>
<span class="line">    <span class="token class-name">SearchRequest</span> searchRequestToUse <span class="token operator">=</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>searchRequest<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">filterExpression</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doGetFilterExpression</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Document</span><span class="token punctuation">&gt;</span></span> documents <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vectorStore<span class="token punctuation">.</span><span class="token function">similaritySearch</span><span class="token punctuation">(</span>searchRequestToUse<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 4. 构建文档上下文</span></span>
<span class="line">    context<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;qa_retrieved_documents&quot;</span><span class="token punctuation">,</span> documents<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">String</span> documentContext <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>documents<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Document</span><span class="token operator">::</span><span class="token function">getText</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">lineSeparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> advisedUserParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">userParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 5. 注入上下文参数</span></span>
<span class="line">    advisedUserParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;question_answer_context&quot;</span><span class="token punctuation">,</span> documentContext<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token class-name">AdvisedRequest</span> advisedRequest <span class="token operator">=</span> <span class="token class-name">AdvisedRequest</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">userText</span><span class="token punctuation">(</span>advisedUserText<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">userParams</span><span class="token punctuation">(</span>advisedUserParams<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">adviseContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span> advisedRequest<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AdvisedRequest 和 AdvisedResponse 是 Spring AI 的增强请求和响应对象。这两个类的作用是在于提供一个增强的上下文，使得在处理请求和响应时可以携带额外的信息，比如用户的查询、上下文信息等。 通过增强请求和响应，可以在处理过程中注入更多的上下文信息，在before中处理请求时，可以根据用户的查询和上下文信息来构建一个更丰富的请求对象。 这里的上下文是通过知识库向量存储（VectorStore）进行检索得到的，增强请求可以包含检索到的相关文档信息。 这里的nextAroundCall和nextAroundStream方法是调用链的一部分，用于在增强请求处理完成后继续执行下一个环节的逻辑。 在aroundCall和aroundStream方法中，增强请求会被传递到下一个环节进行处理。 在处理响应时，增强响应对象可以携带更多的信息，比如检索到的文档信息、处理结果等。 也就是我能从增强相应对象中获取到rag知识库检索到的相关文档信息。</p><h4 id="ai-agent-预热-preheat-流程" tabindex="-1"><a class="header-anchor" href="#ai-agent-预热-preheat-流程"><span>ai-agent 预热（preheat）流程</span></a></h4><ul><li>我们先根据aiClientIds从RootNode节点出发, 异步从库表中查询组装出来业务中流转的VO对象, 并将它们添加到Map中</li><li>然后进入到AiClientToolMcpNode, 根据Map中的MCPVOList组转起来所有McpSyncClient然后将其注册为Bean</li><li>进入到AiClientAdvisorNode, 根据Advisor的类型, 组装rag或者chatmemory类型的bean</li><li>再到AiClientModelNode, 组装OpenAiChatModel并这个model绑定的MCP Tool添加进去</li><li>最后就是AiClientNode将chatModel, MCP, Advisor这三类Bean组装成一个对话客户端ChatClient, 然后将其注册为bean</li></ul><h4 id="ai-agent-对话和定时任务" tabindex="-1"><a class="header-anchor" href="#ai-agent-对话和定时任务"><span>ai-agent 对话和定时任务</span></a></h4><p>对话分成流式对话和普通对话两种</p><p><strong>普通对话-aiAgentChat方法</strong></p><p>获取到完整的AI回答再给出返回</p><ol><li><p>获取所有的client的ID</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">List&lt;Long&gt; aiClientIds = repository.queryAiClientIdsByAiAgentId(aiAgentId);</span>
<span class="line">String content = &quot;&quot;;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>根据clientId取出来对应的client Bean对象, 链式调用这个agent对应的client们, 渐进式提问</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">for (Long aiClientId : aiClientIds) {</span>
<span class="line">ChatClient chatClient = defaultArmoryStrategyFactory.chatClient(aiClientId);</span>
<span class="line">content = chatClient.prompt(message + &quot;，&quot; + content)</span>
<span class="line">                    .system(s -&gt; s.param(&quot;current_date&quot;, LocalDate.now().toString()))</span>
<span class="line">                    .advisors(a -&gt; a</span>
<span class="line">                    .param(CHAT_MEMORY_CONVERSATION_ID_KEY, &quot;chatId 101&quot;)</span>
<span class="line">                    .param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 100))</span>
<span class="line">                    .call().content();</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这里传入的advisor的参数CHAT_MEMORY_CONVERSATION_ID_KEY是用于标识这次对话的ID, 这个ID是用来区分上下文的, 不同的对话有着不同的ID、不同的上下文.</li><li>param(CHAT_MEMORY_RETRIEVE_SIZE_KEY, 100)) 这个参数的作用是将对话历史记录的数量限制在100条。</li></ul><blockquote><p>这里为什么会是链式调用, 一个问题调用一个Client进行回答不就行了吗?</p><p>注意我们的方法名不是clientChat而是agentChat, 一个agent能够串联多个client, 在这个方法中多client协作的工作共同构建最后的回答, 实现功能互补或者质量提升, 亦或是问题分解, 举例: 场景一：专业分工协作</p><p>假设有3个智能体：</p><p>// aiClientId = 1: 文本分析专家</p><p>// aiClientId = 2: 逻辑推理专家</p><p>// aiClientId = 3: 总结归纳专家</p><p>// 第一轮：分析专家处理原始问题</p><p>content = &quot;&quot;; // 初始为空</p><p>content = 分析专家.process(&quot;用户问题&quot; + &quot;，&quot; + &quot;&quot;); // 得到分析结果</p><p>// 第二轮：推理专家基于分析结果进行推理</p><p>content = 推理专家.process(&quot;用户问题&quot; + &quot;，&quot; + &quot;分析结果&quot;); // 得到推理结论</p><p>// 第三轮：总结专家整合前面的结果</p><p>content = 总结专家.process(&quot;用户问题&quot; + &quot;，&quot; + &quot;分析结果+推理结论&quot;); // 最终答案</p><p>场景二：渐进式优化</p><p>// 智能体链逐步完善答案质量</p><p>// 第一个智能体：给出初步答案</p><p>// 第二个智能体：基于初步答案进行补充和优化</p><p>// 第三个智能体：进行最终校验和润色</p></blockquote></li></ol><p><strong>流式对话-aiAgentChatStream方法</strong></p><p>获取到一部分返回以后立马呈现给用户</p><ol><li>获取配置<div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">// 查询模型ID</span>
<span class="line">Long modelId = repository.queryAiClientModelIdByAgentId(aiAgentId);</span>
<span class="line">// 获取对话模型</span>
<span class="line">ChatModel chatModel = defaultArmoryStrategyFactory.chatModel(modelId);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>构建messages <ul><li>如果对话不携带rag, 则messages就只有传入的message</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line"> messages.add(new UserMessage(message));</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>如果携带rag <ol><li>根据ragId获取到tag</li><li>从pg中查询到相近的documents</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">SearchRequest searchRequest = SearchRequest.builder()</span>
<span class="line">                                           .query(message)</span>
<span class="line">                                           .topK(5)</span>
<span class="line">                                           .filterExpression(&quot;knowledge == &#39;&quot; + tag + &quot;&#39;&quot;)</span>
<span class="line">                                           .build();</span>
<span class="line">List&lt;Document&gt; documents = vectorStore.similaritySearch(searchRequest);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>构建结构化的rag prompt</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">String documentCollectors = documents.stream()</span>
<span class="line">                                     .map(Document::getFormattedContent)</span>
<span class="line">                                     .collect(Collectors.joining());</span>
<span class="line">Message ragMessage = new SystemPromptTemplate(&quot;&quot;&quot; .... DOCUMENTS: {documents} &quot;&quot;&quot;)</span>
<span class="line">                                             .createMessage(Map.of(&quot;documents&quot;, documentCollectors));</span>
<span class="line">messages.add(new UserMessage(message));</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li>使用messages与第一步获取到的model对话</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">return chatModel.stream(Prompt.builder()</span>
<span class="line">                .messages(messages)</span>
<span class="line">                .build());</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>为什么这里又不使用链式调用多个client了?</p><p>链式调用多个client的本质是将当前client的输出 + 原问题作为下一个client的输入, 如果这样我们必须阻塞式等待client完整回答完毕, 而当前方法实现的是流式回答, 是输出了一部分就给用户呈现一部分, 所以不能链式调用.</p></blockquote><h4 id="agenttaskjob" tabindex="-1"><a class="header-anchor" href="#agenttaskjob"><span>AgentTaskJob</span></a></h4><p><strong>init方法-在Bean初始化以后执行</strong></p><p>这个方法上有个@PostConstruct注解, 这个注解的功能是在Spring容器初始化完成后执行该方法.这个方法的主要功能就是初始化了一个任务调度器.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">public void init() {</span>
<span class="line">   // 初始化任务调度器</span>
<span class="line">   ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); // 这个类是 Spring 提供的一个线程池任务调度器</span>
<span class="line">   scheduler.setPoolSize(10);</span>
<span class="line">   scheduler.setThreadNamePrefix(&quot;agent-task-scheduler-&quot;);</span>
<span class="line">   scheduler.setWaitForTasksToCompleteOnShutdown(true); // 设置在关闭时等待任务完成</span>
<span class="line">   scheduler.setAwaitTerminationSeconds(60); // 设置等待任务完成的时间</span>
<span class="line">   scheduler.initialize();</span>
<span class="line">   this.taskScheduler = scheduler;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>executeTask方法-执行任务</strong></p><ol><li>获取任务的参数(json格式) String taskParam = task.getTaskParam();</li><li>执行任务 aiAgentChatService.aiAgentChat(task.getAgentId(), taskParam);</li></ol><blockquote><p>这里的执行任务为什么就是aiAgentChat?</p><p>在前面的xfg的mcp章节, 其实就能看到我们让AI执行一个任务就是与AI对话, 让它调用对应的MCP执行特定的任务。 这里也是一样的, 同时agent的链式调用client还能使得我们这个任务由多个client协同执行。</p></blockquote><p><strong>scheduleTask方法-调度器执行任务</strong></p><ol><li>创建任务调度器：调度器要执行的方法就是executeTask(task)；时间设置通过task的cron表达式</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">ScheduledFuture&lt;?&gt; future = taskScheduler.schedule(() -&gt; executeTask(task), new CronTrigger(task.getCronExpression()));</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>将这个任务放到类全局map中, 记录这个任务已经被我们调度执行成功了 scheduledTasks.put(task.getId(), future);</li></ol><p><strong>refreshTasks方法-移除invalid任务, 执行valid任务</strong></p><ol><li>从taskService中查询到所有有效的任务配置</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">List&lt;AiAgentTaskScheduleVO&gt; taskSchedules =  aiAgentTaskService.queryAllValidTaskSchedule();</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>处理每个任务:将这个任务的id放入到Map中, 用于后面删除调度器中已经invalid任务;如果任务不存在调用scheduleTask(task)创建并调度新任务</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">for (AiAgentTaskScheduleVO task : taskSchedules) {</span>
<span class="line">   Long taskId = task.getId();</span>
<span class="line">   currentTaskIds.put(taskId, true);</span>
<span class="line">   // 如果任务已经存在，则跳过</span>
<span class="line">   if (scheduledTasks.containsKey(taskId)) {</span>
<span class="line">      continue;</span>
<span class="line">   }</span>
<span class="line">   // 创建并调度新任务</span>
<span class="line">   scheduleTask(task);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>移除不存在的任务:获取现在所有在调度器中的任务的keySet, 也就是所有在调度器中的任务的taskId集合A; 上面处理每个任务的时候记录的现在仍然有效的taskId集合B, 如果A不在B中, 说明这个任务已经不存在了;从调度器task集合中获取任务并将任务移除.</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">scheduledTasks.keySet().removeIf(taskId -&gt; {</span>
<span class="line">    if (!currentTaskIds.containsKey(taskId)) {</span>
<span class="line">        ScheduledFuture&lt;?&gt; future = scheduledTasks.remove(taskId);</span>
<span class="line">        if (future != null) {</span>
<span class="line">            future.cancel(true);</span>
<span class="line">            log.info(&quot;已移除任务，ID: {}&quot;, taskId);</span>
<span class="line">        }</span>
<span class="line">        return true;</span>
<span class="line">    }</span>
<span class="line">    return false;</span>
<span class="line"> });</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>cleanInvalidTasks方法-清理已经被标记为无效的任务</strong></p><ol><li>获取所有已经失效的任务的ID: <code>List&lt;Long&gt; invalidTaskIds = aiAgentTaskService.queryAllInvalidTaskScheduleIds()</code>;</li><li>从调度器中移除这些任务</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">for (Long taskId : invalidTaskIds) {</span>
<span class="line">    ScheduledFuture&lt;?&gt; future = scheduledTasks.remove(taskId);</span>
<span class="line">    if (future != null) {</span>
<span class="line">        future.cancel(true);</span>
<span class="line">        log.info(&quot;已移除无效任务，ID: {}&quot;, taskId);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>chat和task模块可以说是看似简单的实现, 但是具有很强的拓展性, 比如我想设置一个监控数据监控面板然后发现异常微信推送消息的组件</p><ol><li>实现能从数据监控面板获取数据的MCP工具</li><li>实现发送微信消息的MCP工具</li><li>注册一个分析数据监控面板client, 注册一个发送总结分析发送微信消息的client</li><li>将两个client串联成一个agent, 设置这个agent的定时任务</li><li>这样就实现了监控数据面板在AI分析即将出现问题的时候通知开发者的功能</li></ol><h3 id="扩展和优化思路" tabindex="-1"><a class="header-anchor" href="#扩展和优化思路"><span>扩展和优化思路</span></a></h3><p>可以尝试与市面上的Dify/扣子等等智能体对比，阐明自己的优势。</p><ul><li>冷热数据分层存储；索引优化， 对于向量库采用 MSTG 索引算法，</li><li>采用父子分段模式作为数据分块策略，并在向量检索时增加重新排序步骤。</li><li>对于多模型，引入 one-api 组件，实现多模型适配，可以针对不同模型配置独立连接池，避免资源争抢。</li><li>图文混合检索：集成 CLIP 模型，支持用户上传图片或 PDF 后，结合文本进行联合检索。</li><li>语音交互：通过 Whisper 模型实现语音转文本输入，结合 TTS 生成语音回答。</li><li>动态规划引擎：引入强化学习（如 PPO 算法），让 Agent 根据历史反馈自主优化执行策略。</li><li>因果推理：支持多步因果推断（如“用户询问销量下降原因→分析市场趋势→建议促销方案”）。</li><li>对话增强：当用户提问模糊时， Agent 主动追问细节，在对话历史中嵌入图片、表格等富媒体内容，结合用户历史行为，动态调整回答风格。</li></ul>`,75)]))}const v=s(o,[["render",u]]),m=JSON.parse('{"path":"/blogs/Project/RAG/3.html","title":"AI-Agent 智能体-开发总结","lang":"en-US","frontmatter":{"title":"AI-Agent 智能体-开发总结","date":"2025/08/15","tags":["DeepSeek","前后端分离","SpringAI","Flux","ostgresql","Redis","Nginx","Docker"],"categories":["后端开发"]},"headers":[{"level":3,"title":"难点及解决","slug":"难点及解决","link":"#难点及解决","children":[]},{"level":3,"title":"问题","slug":"问题","link":"#问题","children":[]},{"level":3,"title":"扩展和优化思路","slug":"扩展和优化思路","link":"#扩展和优化思路","children":[]}],"git":{"createdTime":1755092504000,"updatedTime":1755092504000,"contributors":[{"name":"zxy","email":"zxy0613zxy@outlook.com","commits":1}]},"filePathRelative":"blogs/Project/RAG/3.md"}');export{v as comp,m as data};
