import{_ as a,c as s,a as e,o as t}from"./app-ByLG9LQz.js";const l="/assets/img_10-DZyq705l.png",i={};function p(c,n){return t(),s("div",null,n[0]||(n[0]=[e('<h2 id="动态限流" tabindex="-1"><a class="header-anchor" href="#动态限流"><span>动态限流</span></a></h2><p>基于Guava RateLimiter 限流组件，使用 aop 切面技术，实现一款统一限流服务组件。对于频繁访问的用户动态添加黑名单拦截，再通过动态调用方法返回拦截后的结果信息。</p><p>限流的策略是, 如果用户的QPS超过了注解中的QPS值, 就会执行限流回调函数, 并将用户的被限流次数++, 如果用户的被限流次数超过了注解中的blacklistCount, 用户就相当于被添加到黑名单, 会在24h内只执行限流回调函数, 通过cache将用户绑定到Ratelimiter上, 通过令牌桶来判断用户流量是不是超过了规定值, 令牌桶1min过期</p><h3 id="流程设计" tabindex="-1"><a class="header-anchor" href="#流程设计"><span>流程设计</span></a></h3><p><img src="'+l+`" alt="img_10.png"></p><ul><li>增加SPI机制，动态的处理组件的加载，以把动态限流封装成统一的组件给其他业务服务使用。</li><li>在使用了AOP切面插入的地方，如 @DCC 直接获取类操作属性要考虑代理类的存在。</li><li>RateLimiter 限流，当一个用户频繁访问超过N次后，则会将这个用户加入黑名单列表，不允许在访问当前服务。直至过了超时时间从黑名单列表移走后才允许访问。</li></ul><h3 id="程序的串行执行过程" tabindex="-1"><a class="header-anchor" href="#程序的串行执行过程"><span>程序的串行执行过程</span></a></h3><ol><li>@RateLimiterAccessInterceptor注解到需要拦截的方法上</li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token annotation punctuation">@Documented</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">RateLimiterAccessInterceptor</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">String</span> <span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">&quot;all&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 限制频次: 每秒请求次数</span></span>
<span class="line">    <span class="token keyword">double</span> <span class="token function">permitsPerSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 黑名单拦截: 多少次限制以后加入到黑名单, 0代表不做限制</span></span>
<span class="line">    <span class="token keyword">double</span> <span class="token function">blacklistCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 拦截后执行的方法</span></span>
<span class="line">    <span class="token class-name">String</span> <span class="token function">fallbackMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>限流执行流程</strong></p><ul><li>通过 spring.factories 文件中的自动配置项，Spring Boot启动时加载 RateLimiterAutoConfig ，并创建 RateLimiterAOP 切面实例。</li><li>RateLimiterAOP 中的 @DCCValue(&quot;rateLimiterSwitch:open&quot;) 注解会从动态配置中心获取限流开关状态。</li><li>RateLimiterAOP对象拦截所有被@RateLimiterAccessInterceptor注解的方法 <ol><li>通过第一节的DCC来动态配置限流组件的状态(打开还是关闭)，通过反射从方法参数中提取用户标识</li><li>执行黑名单过滤, 在黑名单中, 执行注解中的fallbackMethod</li><li>如果该用户不在黑名单中, 则通过令牌桶限流</li><li>如果用户获取令牌失败, 也就是超过了限定的QPS(注解中的permitsPerSecond), 则进行限流 <ol><li>将用户的被限流次数+1(如果用户被限流次数超过了注解中的blacklistCount, 就会执行黑名单过滤了)</li><li>执行注解中的fallbackMethod</li></ol></li></ol></li></ul><h3 id="技术细节" tabindex="-1"><a class="header-anchor" href="#技术细节"><span>技术细节</span></a></h3><ul><li>fallbackMethod必须定义在被注解的方法所在的类上, 不能跨类, 因为是通过反射获取到这个方法的</li><li>获取Cache的key通过反射从方法的入参中获取, 不能通过<code>filedValue = BeanUtils.getProperty(arg, attr);</code>获取, 因为使用了lombok对于uid这样的字段, 生成的get方法是getuid, 而使用IDEA生成的标准的get方法是getUid, 使用lombok的时候会无法获取到属性的值, 所以需要通过反射获取</li></ul>`,13)]))}const r=a(i,[["render",p]]),u=JSON.parse('{"path":"/blogs/Project/wrench/wrench3.html","title":"通用技术组件-开发日志3-动态限流","lang":"en-US","frontmatter":{"title":"通用技术组件-开发日志3-动态限流","date":"2025/8/10","tags":["动态配置","组件开发"],"categories":["后端开发"]},"headers":[{"level":2,"title":"动态限流","slug":"动态限流","link":"#动态限流","children":[{"level":3,"title":"流程设计","slug":"流程设计","link":"#流程设计","children":[]},{"level":3,"title":"程序的串行执行过程","slug":"程序的串行执行过程","link":"#程序的串行执行过程","children":[]},{"level":3,"title":"技术细节","slug":"技术细节","link":"#技术细节","children":[]}]}],"git":{"createdTime":1754750100000,"updatedTime":1755092504000,"contributors":[{"name":"zxy","email":"zxy0613zxy@outlook.com","commits":2}]},"filePathRelative":"blogs/Project/wrench/wrench3.md"}');export{r as comp,u as data};
