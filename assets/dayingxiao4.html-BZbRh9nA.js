import{_ as e,c as l,a,o as s}from"./app-CwN1xCkZ.js";const n="/assets/img_60-If296Ak3.png",t="/assets/img_61-DxmGrOqP.jpg",r="/assets/img_62-DgS268mg.jpg",d="/assets/img_61-DJ4JNC2e.png",c="/assets/img_62-yTC7-sou.png",p="/assets/img_63-Bpz86k3F.png",o="/assets/img_42-BLrBxT5Y.png",u="/assets/img_57-7eHHunRc.png",m="/assets/img_58-BEIwIau2.png",_="/assets/img_59-CUdqQsyF.png",h="/assets/img_66-DaBNAbR3.png",g="/assets/img_67-DTVwsNDX.png",v="/assets/img_68-egkYlj1P.png",b="/assets/img_69-8Qf7lZCV.png",y="/assets/img_70-D4asfQQ_.png",f="/assets/img_71-nO9S8UAx.png",x="/assets/img_72-CpL3x618.png",S="/assets/img_73-B_mzSeUS.png",D="/assets/img_74-Bshn2lVD.png",k="/assets/img_75-Dcf-gYAZ.png",T="/assets/img_76-QB_CEwzr.png",I="/assets/img_77-CqAhMTRF.png",R={};function C(M,i){return s(),l("div",null,i[0]||(i[0]=[a(`<h3 id="难点及解决" tabindex="-1"><a class="header-anchor" href="#难点及解决"><span>难点及解决</span></a></h3><h4 id="一、高并发场景下的库存管理" tabindex="-1"><a class="header-anchor" href="#一、高并发场景下的库存管理"><span>一、高并发场景下的库存管理</span></a></h4><p>难点：</p><ol><li>超卖风险：秒杀场景下，高并发请求可能导致库存超卖。</li><li>性能瓶颈：传统数据库行锁在高并发下会成为瓶颈，导致连接池耗尽、请求堆积，影响吞吐量。</li><li>数据一致性：Redis缓存与MySQL数据库的一致性维护。</li><li>Redis 集群环境下，decr 操作可能因网络抖动、主从切换等出现数据不一致，引发超卖。</li></ol><p>解决方案：</p><ol><li>分段锁+乐观锁： <ul><li>使用Redis的DECR命令实现无锁化扣减。</li><li>使用 setNX 对每个扣减后的库存值加锁（如 stock_lock:A:96），防止重复扣减。这种方案的本质是 “用细粒度的锁控制库存值的原子变化”，通过 SETNX 确保 “每个扣减后的库存值” 只能被一个请求处理，从而防止高并发下的重复扣减和超卖。其优势是并发性能更高，适合秒杀等高频场景，但需注意锁的管理复杂度和资源占用问题。实际应用中，需根据业务并发量和库存扣减规则，选择 “商品级锁” 或 “库存值锁” 方案。</li><li>锁的过期时间设置为活动结束时间 + 1天，避免手动释放的复杂度。</li><li>若 DECR 后库存 &lt;0，立即恢复为 0。若 setNX 失败，说明该库存编号已被占用，拒绝本次扣减。</li></ul></li><li>异步更新与最终一致性： <ul><li>扣减成功后通过MQ异步更新MySQL，使用延迟队列（如RabbitMQ）控制数据库更新频率，降低数据库瞬时压力。</li><li>活动结束后，通过任务扫描订单记录校准库存。</li><li>消息携带唯一业务ID（如订单ID），消费端做幂等处理。</li><li>使用 task 表记录待发送消息，定时任务补偿发送失败的消息。</li><li>抽奖流程中，抽奖订单创建与抽奖结果落库分属不同事务，通过状态机与补偿任务保证一致性。</li></ul></li><li>库存预热与动态调整： <ul><li>活动开始前将库存加载到Redis，避免实时计算。</li><li>运营补货时重新预热Redis库存区间，避免并发冲突。</li></ul></li></ol><h4 id="二、规则引擎的动态配置与扩展性" tabindex="-1"><a class="header-anchor" href="#二、规则引擎的动态配置与扩展性"><span>二、规则引擎的动态配置与扩展性</span></a></h4><p>难点：</p><ol><li>规则复杂性：抽奖规则涉及黑名单、权重、次数锁等多维度条件。</li><li>灵活性需求：需支持运营动态调整规则，无需重启服务。</li><li>性能损耗：规则引擎的动态解析可能引入计算开销。</li></ol><p>解决方案：</p><ol><li>责任链模式+组合模式： <ul><li>将规则拆分为独立节点（如黑名单、权重），通过责任链串联执行。</li><li>使用组合模式构建规则树。支持多分支判断（如次数锁 → 库存检查 → 兜底奖品）。</li></ul></li><li>动态配置与热更新： <ul><li>规则配置信息存储在数据库，支持页面拖拽配置。。</li><li>使用Redis缓存规则树与责任链，结合ZooKeeper动态更新配置。规则配置变更后，清除 Redis 缓存，下次访问自动加载最新配置。</li></ul></li><li>策略模式解耦： <ul><li>每种规则类型对应独立策略类（如RuleWeightLogicTreeNode），通过Spring原型模式管理。</li><li>抽象工厂（DefaultTreeFactory）动态组装规则树。</li></ul></li></ol><h4 id="三、分库分表与数据一致性" tabindex="-1"><a class="header-anchor" href="#三、分库分表与数据一致性"><span>三、分库分表与数据一致性</span></a></h4><p>难点：</p><ol><li>水平扩展：单表数据量过大时，需分库分表提升性能。</li><li>查询效率：分片后无法直接执行跨表聚合查询。用户行为数据分散在多个库表中，运营端如何做聚合查询？ 分库分表后，如何支持非分片键查询？</li><li>事务一致性：分库分表后本地事务无法保证跨库操作。</li></ol><p>解决方案：</p><ol><li>一致性Hash分片： <ul><li>按用户ID分片，使用DBRouter组件动态路由SQL。</li><li>为 username 等非分片键建立 username → userId 的映射表或缓存。</li><li>示例路由逻辑： <code>int dbIndex = Math.abs(userId.hashCode()) % dbCount;</code></li></ul></li><li>Canal+ES同步： <ul><li>通过Canal监听MySQL Binlog，实时同步数据到Elasticsearch。</li><li>运营查询走 ES，实现近实时聚合分析。</li></ul></li><li>补偿机制： <ul><li><p>对分片键查询失败的场景（如按用户名查询），通过基因法生成分片ID。</p></li><li><p>示例： <code>String gene = username.substring(0, 2); // 取前两位作为分片基因</code></p></li></ul></li></ol><p>四、分布式锁与高可用设计</p><p>难点：</p><ol><li>锁竞争：高并发下分布式锁的获取与释放效率。</li><li>容灾能力：Redis集群故障时如何避免系统崩溃。</li><li>死锁风险：锁过期或异常导致资源无法释放。</li></ol><p>解决方案：</p><ol><li>Redisson分布式锁： <ul><li>使用RedLock算法，支持多节点选举。</li><li>设置锁过期时间（如活动结束时间+1天），避免永久阻塞。</li><li>示例：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">RLock lock = redisson.getLock(&quot;activity_lock:&quot; + activityId);</span>
<span class="line">lock.lock(leaseTime, TimeUnit.MILLISECONDS);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li>降级与熔断： <ul><li>基于 @RateLimiter 注解实现用户维度限流，黑名单用户存入 Guava 缓存。</li><li>使用Hystrix或Sentinel实现熔断机制。</li></ul></li><li>本地缓存兜底： <ul><li>对高频查询数据（如奖品配置）使用本地缓存（Guava），减少Redis压力。</li><li>设置缓存过期时间与Redis同步，避免数据不一致。</li></ul></li></ol><h4 id="五、系统监控与性能优化" tabindex="-1"><a class="header-anchor" href="#五、系统监控与性能优化"><span>五、系统监控与性能优化</span></a></h4><p>难点：</p><ol><li>实时监控：高并发下快速定位性能瓶颈。</li><li>日志分析：海量日志的存储与检索。</li><li>调优策略：JVM参数与数据库配置优化。</li><li>分布式任务在多实例下如何避免重复执行？</li></ol><p>解决方案：</p><ol><li>Prometheus+Grafana监控： <ul><li>监控JVM、线程池、数据库连接、Redis 等关键指标。</li><li>设置阈值告警（如RT&gt;500ms触发告警）。</li></ul></li><li>链路追踪： <ul><li>使用SkyWalking或Zipkin追踪请求链路。</li><li>定位慢SQL和异常调用。</li></ul></li><li>JVM调优： <ul><li>调整堆内存参数（如-Xmx6g），减少Full GC频率。</li><li>使用G1垃圾回收器优化吞吐量。</li></ul></li><li>XXL-Job + Redis 分布式锁 <ul><li>任务执行前抢占 Redis 锁，确保同一任务在同一时刻只有一个实例执行。</li></ul></li></ol><h3 id="整体流程图" tabindex="-1"><a class="header-anchor" href="#整体流程图"><span>整体流程图</span></a></h3><p>截止在第二部分，抽奖系统以“装配—参与—抽奖—结算”四段式流程为主线：首先，活动装配阶段会把目标活动的基础信息、SKU 库存与SKU发放策略、奖品清单及其概率散列表（若规则中包含积分决定奖品，则将积分-奖品散列表一并）统一加载进 Redis。 装配完成后，用户可通过购买、签到等多种 SKU 活动累积抽奖次数；系统会验证 SKU 活动是否处于有效期、库存是否充足，校验通过后在一个事务内同时为用户增加账户总额度，并在 raffle_activity_order 表写入流水，确保额度与订单原子一致。</p><p>当用户发起抽奖请求时，系统先校验活动可用性，再查询是否存在状态为 noused 的待抽奖订单；若存在直接返回，否则按“总额度-月额度-日额度”三级维度顺序扣减，并生成 user_raffle_order 记录。 扣减过程中，SKU 库存以 Redis 原子扣减为准，扣到 0 时异步发布消息回刷数据库；奖品库存则是在 Redis 扣减后通过 MQ 触发单件落库，避免超卖。（这里也会采用商品库存槽位锁来确保）</p><p>抽奖逻辑分三段：抽奖前、抽奖中、抽奖后。抽奖前根据活动 ID 动态装配责任链：若未定制链，则走默认链；若链中配置了黑名单、积分权重等节点，则优先判定——命中黑名单或已由积分直接命中奖品时，流程短路直接返回，不再进入后续规则树。 若责任链放行，进入抽奖后阶段的规则树处理。抽奖后通过活动-规则树 ID 建立树根、节点、边的有序结构，装配规则引擎并逐节点校验次数门槛、库存阈值等条件；若某一步校验失败则走幸运奖兜底，具体奖项依数据库树配置而定。</p><p>当最终中奖结果产生，系统会把 user_raffle_order 状态更新为 used，并把中奖内容写入 user_award_account ；随后异步发送 MQ 消息通知下游做奖品发放，并在任务表写入一条补偿任务，以便消息丢失时可定时重推，保证全链路一致性与可恢复性。</p><p>整体方案以领域分层（domain、infrastructure、trigger）、责任链 + 规则树双层过滤、Redis 原子扣减 + MQ-Task 最终一致、事务保障一致四大技术手段，确保高并发下的抽奖正确性与库存安全。</p><h4 id="装配活动和抽奖策略" tabindex="-1"><a class="header-anchor" href="#装配活动和抽奖策略"><span>装配活动和抽奖策略</span></a></h4><p><img src="`+n+'" alt="img_60.png"></p><h4 id="抽奖" tabindex="-1"><a class="header-anchor" href="#抽奖"><span>抽奖</span></a></h4><p><img src="'+t+'" alt="img_61.jpg"></p><h4 id="返利-sku库存操作" tabindex="-1"><a class="header-anchor" href="#返利-sku库存操作"><span>返利&amp;sku库存操作</span></a></h4><p><img src="'+r+'" alt="img_62.jpg"></p><h4 id="积分兑换商品" tabindex="-1"><a class="header-anchor" href="#积分兑换商品"><span>积分兑换商品</span></a></h4><p><img src="'+d+'" alt="img_61.png"></p><h4 id="mq发奖监听和积分发货" tabindex="-1"><a class="header-anchor" href="#mq发奖监听和积分发货"><span>MQ发奖监听和积分发货</span></a></h4><p><img src="'+c+'" alt="img_62.png"><img src="'+p+'" alt="img_63.png"></p><h3 id="行为驱动的数据库表er图" tabindex="-1"><a class="header-anchor" href="#行为驱动的数据库表er图"><span>行为驱动的数据库表er图</span></a></h3><p><img src="'+o+'" alt="img_42.png"></p><h4 id="_1-award-奖品表" tabindex="-1"><a class="header-anchor" href="#_1-award-奖品表"><span>1. award（奖品表）</span></a></h4><p>用于存储抽奖活动中的奖品信息。</p><ul><li>id ：自增ID</li><li>award_id ：抽奖奖品ID（内部流转使用）</li><li>award_key ：奖品对接标识（每个都是一个对应的发奖策略）</li><li>award_config ：奖品配置信息</li><li>award_desc ：奖品内容描述</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_2-daily-behavior-rebate-日常行为返利活动配置" tabindex="-1"><a class="header-anchor" href="#_2-daily-behavior-rebate-日常行为返利活动配置"><span>2. daily_behavior_rebate（日常行为返利活动配置）</span></a></h4><p>用于配置用户日常行为可获得的返利。</p><ul><li>id ：自增ID</li><li>behavior_type ：行为类型（如sign签到、openai_pay支付）</li><li>rebate_desc ：返利描述</li><li>rebate_type ：返利类型（如sku活动库存充值商品、integral用户活动积分）</li><li>rebate_config ：返利配置</li><li>state ：状态（open开启、close关闭）</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_3-raffle-activity-抽奖活动表" tabindex="-1"><a class="header-anchor" href="#_3-raffle-activity-抽奖活动表"><span>3. raffle_activity（抽奖活动表）</span></a></h4><p>存储抽奖活动的基本信息。</p><ul><li>id ：自增ID</li><li>activity_id ：活动ID</li><li>activity_name ：活动名称</li><li>activity_desc ：活动描述</li><li>begin_date_time ：开始时间</li><li>end_date_time ：结束时间</li><li>strategy_id ：抽奖策略ID</li><li>state ：活动状态（如create创建、open开启）</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_4-raffle-activity-count-抽奖活动次数配置表" tabindex="-1"><a class="header-anchor" href="#_4-raffle-activity-count-抽奖活动次数配置表"><span>4. raffle_activity_count（抽奖活动次数配置表）</span></a></h4><p>配置用户参与抽奖活动的次数限制。</p><ul><li>id ：自增ID</li><li>activity_count_id ：活动次数编号</li><li>total_count ：总次数</li><li>day_count ：日次数</li><li>month_count ：月次数</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_5-raffle-activity-sku-活动商品sku表" tabindex="-1"><a class="header-anchor" href="#_5-raffle-activity-sku-活动商品sku表"><span>5. raffle_activity_sku（活动商品SKU表）</span></a></h4><p>存储活动商品的库存和价格信息。</p><ul><li>id ：自增ID</li><li>sku ：商品SKU（将每个组合作为一个商品）</li><li>activity_id ：活动ID</li><li>activity_count_id ：活动个人参与次数ID</li><li>stock_count ：商品库存总量</li><li>stock_count_surplus ：剩余库存</li><li>product_amount ：商品金额（积分）</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_6-rule-tree-规则表-树" tabindex="-1"><a class="header-anchor" href="#_6-rule-tree-规则表-树"><span>6. rule_tree（规则表-树）</span></a></h4><p>定义规则树的基本信息。</p><ul><li>id ：自增ID</li><li>tree_id ：规则树ID</li><li>tree_name ：规则树名称</li><li>tree_desc ：规则树描述</li><li>tree_node_rule_key ：规则树根入口规则</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_7-rule-tree-node-规则表-树节点" tabindex="-1"><a class="header-anchor" href="#_7-rule-tree-node-规则表-树节点"><span>7. rule_tree_node（规则表-树节点）</span></a></h4><p>存储规则树中的节点信息。</p><ul><li>id ：自增ID</li><li>tree_id ：规则树ID</li><li>rule_key ：规则Key</li><li>rule_desc ：规则描述</li><li>rule_value ：规则比值</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_8-rule-tree-node-line-规则表-树节点连线" tabindex="-1"><a class="header-anchor" href="#_8-rule-tree-node-line-规则表-树节点连线"><span>8. rule_tree_node_line（规则表-树节点连线）</span></a></h4><p>存储规则树中节点之间的连线关系和条件。</p><ul><li>id ：自增ID</li><li>tree_id ：规则树ID</li><li>rule_node_from ：规则Key节点From</li><li>rule_node_to ：规则Key节点To</li><li>rule_limit_type ：限定类型（1:=;2:&gt;;3:&lt;;4:&gt;=;5&lt;=;6:enum[枚举范围]）</li><li>rule_limit_value ：限定值（到下个节点的条件）</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_9-strategy-抽奖策略表" tabindex="-1"><a class="header-anchor" href="#_9-strategy-抽奖策略表"><span>9. strategy（抽奖策略表）</span></a></h4><p>定义抽奖活动的策略配置。</p><ul><li>id ：自增ID</li><li>strategy_id ：抽奖策略ID</li><li>strategy_desc ：抽奖策略描述</li><li>rule_models ：规则模型（rule配置的模型同步到此表，便于使用）</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_10-strategy-award-抽奖策略奖品概率表" tabindex="-1"><a class="header-anchor" href="#_10-strategy-award-抽奖策略奖品概率表"><span>10. strategy_award（抽奖策略奖品概率表）</span></a></h4><p>存储抽奖策略中各奖品的概率和库存信息。</p><ul><li>id ：自增ID</li><li>strategy_id ：抽奖策略ID</li><li>award_id ：抽奖奖品ID</li><li>award_title ：抽奖奖品标题</li><li>award_subtitle ：抽奖奖品副标题</li><li>award_count ：奖品库存总量</li><li>award_count_surplus ：奖品库存剩余</li><li>award_rate ：奖品中奖概率</li><li>rule_models ：规则模型</li><li>sort ：排序</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_11-strategy-rule-抽奖策略规则表" tabindex="-1"><a class="header-anchor" href="#_11-strategy-rule-抽奖策略规则表"><span>11. strategy_rule（抽奖策略规则表）</span></a></h4><p>存储抽奖策略的具体规则配置。</p><ul><li>id ：自增ID</li><li>strategy_id ：抽奖策略ID</li><li>award_id ：抽奖奖品ID（规则类型为策略时不需要）</li><li>rule_type ：抽象规则类型（1-策略规则、2-奖品规则）</li><li>rule_model ：抽奖规则类型（如rule_random随机值计算、rule_lock抽奖几次后解锁、rule_luck_award幸运奖）</li><li>rule_value ：抽奖规则比值</li><li>rule_desc ：抽奖规则描述</li><li>create_time / update_time ：创建/更新时间</li></ul><h4 id="_1-raffle-activity-account-抽奖活动账户表" tabindex="-1"><a class="header-anchor" href="#_1-raffle-activity-account-抽奖活动账户表"><span>1. raffle_activity_account（抽奖活动账户表）</span></a></h4><p>记录用户在特定活动中的参与次数配额和剩余次数。</p><ul><li>id ：自增ID</li><li>user_id ：用户ID</li><li>activity_id ：活动ID</li><li>total_count ：总次数配额</li><li>day_count ：日次数配额</li><li>month_count ：月次数配额</li><li>total_count_surplus ：剩余总次数</li><li>day_count_surplus ：剩余日次数</li><li>month_count_surplus ：剩余月次数</li><li>create_time ：创建时间</li><li>update_time ：更新时间</li></ul><h4 id="_2-raffle-activity-account-day-抽奖活动账户日次数表" tabindex="-1"><a class="header-anchor" href="#_2-raffle-activity-account-day-抽奖活动账户日次数表"><span>2. raffle_activity_account_day（抽奖活动账户日次数表）</span></a></h4><p>专门记录用户在特定活动中的每日参与次数和剩余次数，用于每日次数限制。</p><ul><li>id ：自增ID</li><li>user_id ：用户ID</li><li>activity_id ：活动ID</li><li>day_count ：日次数配额</li><li>day_count_surplus ：剩余日次数</li><li>create_time ：创建时间</li><li>update_time ：更新时间</li></ul><h4 id="_3-raffle-activity-account-month-抽奖活动账户月次数表" tabindex="-1"><a class="header-anchor" href="#_3-raffle-activity-account-month-抽奖活动账户月次数表"><span>3. raffle_activity_account_month（抽奖活动账户月次数表）</span></a></h4><p>专门记录用户在特定活动中的每月参与次数和剩余次数，用于每月次数限制。</p><ul><li>id ：自增ID</li><li>user_id ：用户ID</li><li>activity_id ：活动ID</li><li>month_count ：月次数配额</li><li>month_count_surplus ：剩余月次数</li><li>create_time ：创建时间</li><li>update_time ：更新时间</li></ul><h4 id="_4-raffle-activity-order-000-001-002-003-抽奖活动订单表-分表" tabindex="-1"><a class="header-anchor" href="#_4-raffle-activity-order-000-001-002-003-抽奖活动订单表-分表"><span>4. raffle_activity_order_000/001/002/003（抽奖活动订单表，分表）</span></a></h4><p>记录用户购买抽奖次数的订单信息，采用分表策略存储大量订单数据。</p><ul><li>id ：自增ID</li><li>user_id ：用户ID</li><li>sku ：商品SKU（对应不同的抽奖次数包）</li><li>activity_id ：活动ID</li><li>activity_name ：活动名称</li><li>strategy_id ：抽奖策略ID</li><li>order_id ：订单ID</li><li>order_time ：下单时间</li><li>total_count ：购买的总次数</li><li>day_count ：购买的日次数</li><li>month_count ：购买的月次数</li><li>pay_amount ：支付金额（积分）</li><li>state ：订单状态（completed-已完成）</li><li>out_business_no ：业务防重ID（确保幂等）</li><li>create_time ：创建时间</li><li>update_time ：更新时间</li></ul><h4 id="_5-task-任务表" tabindex="-1"><a class="header-anchor" href="#_5-task-任务表"><span>5. task（任务表）</span></a></h4><p>记录需要发送到消息队列（MQ）的异步任务，如发放奖品、积分返利等。</p><ul><li>id ：自增ID</li><li>user_id ：用户ID</li><li>topic ：消息主题（如send_award-发送奖品、send_rebate-发送返利、credit_adjust_success-积分调整成功）</li><li>message_id ：消息编号</li><li>message ：消息主体（JSON格式，包含任务详情）</li><li>state ：任务状态（create-创建、completed-完成、fail-失败）</li><li>create_time ：创建时间</li><li>update_time ：更新时间</li></ul><h4 id="_6-user-award-record-000-001-002-003-用户中奖记录表-分表" tabindex="-1"><a class="header-anchor" href="#_6-user-award-record-000-001-002-003-用户中奖记录表-分表"><span>6. user_award_record_000/001/002/003（用户中奖记录表，分表）</span></a></h4><p>记录用户在抽奖活动中的中奖信息和奖品发放状态，采用分表策略存储大量中奖记录。</p><ul><li>id ：自增ID</li><li>user_id ：用户ID</li><li>activity_id ：活动ID</li><li>strategy_id ：抽奖策略ID</li><li>order_id ：抽奖订单ID（作为幂等使用）</li><li>award_id ：奖品ID</li><li>award_title ：奖品标题（名称）</li><li>award_time ：中奖时间</li><li>award_state ：奖品状态（create-创建、completed-发奖完成）</li><li>create_time ：创建时间</li><li>update_time ：更新时间</li></ul><h4 id="为什么要这样设计-设计的好处是什么" tabindex="-1"><a class="header-anchor" href="#为什么要这样设计-设计的好处是什么"><span>为什么要这样设计，设计的好处是什么</span></a></h4><ul><li>模块化设计: 每个表都具有独立的功能，并通过外键关联，形成一个清晰、可扩展的结构。 award 表专注于奖品的管理， strategy 表负责抽奖策略的定义， strategy_award 表负责策略与奖 品的关联， strategy_rule 表则定义了具体的抽奖规则等等。这种模块化设计便于维护和扩展。</li><li>易于扩展: 通过将奖品、策略、和规则分开，系统可以轻松地添加新的奖品、调整策略或修改规则， 而不需要对整个系统进行大幅度更改。例如，可以通过向 award 表中添加新记录来增加新的奖品，或者通过更新 strategy_rule 表来修改现有的抽奖规则。</li><li>数据管理与性能优化: 各表中的数据被精细地管理，如 strategy_award 表中的奖品库存量、中奖概率和排序字段，可以帮助优化抽奖过程中的性能，确保数据查询和逻辑判断的高效执行。创建raffle_activity_sku存储活动商品。此外，使用 诸如 create_time 和 update_time 字段，可以很方便地追踪数据的历史变化，这对于调试和分析都是非常有利的。</li><li>解耦与灵活性: 通过将策略和规则解耦，允许开发人员在不影响奖品设置的情况下，独立地调整策略或规则。这种灵活性使得系统在面对不同需求时，能够快速地做出相应的调整。例如，在 strategy_rule 表中，可以定义新的规则模型来实现不同的抽奖逻辑。</li></ul><h4 id="设计思路" tabindex="-1"><a class="header-anchor" href="#设计思路"><span>设计思路</span></a></h4><ul><li>可扩展性: 设计思路的核心在于确保系统的可扩展性。在实际开发中，业务需求常常会发生变化，可 能需要添加新的奖品、修改策略或调整规则。通过将不同的功能模块分开设计，可以在不 破坏现有系统的情况下进行扩展和调整。</li><li>高内聚、低耦合: 这种设计确保了表与表之间的低耦合性，使得每个模块能够独立发展和维护。同时，高内 聚性则确保了每个模块的职责清晰明确，这样在维护时可以更容易定位问题和优化性能。</li><li>灵活的规则配置: 策略和规则的分离设计使得系统能够根据业务需求随时调整抽奖的逻辑。例如，可以轻松 地引入新规则、调整现有规则的参数，或者修改策略的组合方式。这种灵活性使得系统能 够更好地应对多变的市场需求。</li></ul><h3 id="业务架构图" tabindex="-1"><a class="header-anchor" href="#业务架构图"><span>业务架构图</span></a></h3><p><img src="'+u+'" alt="img_57.png"></p><h3 id="应用架构图" tabindex="-1"><a class="header-anchor" href="#应用架构图"><span>应用架构图</span></a></h3><p><img src="'+m+'" alt="img_58.png"></p><h3 id="部署架构图" tabindex="-1"><a class="header-anchor" href="#部署架构图"><span>部署架构图</span></a></h3><p><img src="'+_+`" alt="img_59.png"></p><h3 id="bug及解决" tabindex="-1"><a class="header-anchor" href="#bug及解决"><span>bug及解决</span></a></h3><h4 id="责任链模式处理抽奖规则" tabindex="-1"><a class="header-anchor" href="#责任链模式处理抽奖规则"><span>责任链模式处理抽奖规则</span></a></h4><p>DefaultChainFactory.openLogicChain(Long strategyId) 获取到的ILogicChain会存在并发问题，下面是我的思路:</p><ol><li>DefaultChainFactory是个单例bean，spring在构建的时候会把所有的ILogicChain接口的bean（也是单例，一个名字比如&quot;rule_blacklist&quot;对应一个）填到logicChainGroup里。</li><li>在调用openLogicChain(Long strategyId)的时候会按String[] ruleModels（假设是1,2,3）的顺序从logicChainGroup中取得ILogicChain接口的bean，把他们穿起来（像链表一样，bean 1指向bean2，bean2指向bean3，最后指向bean default），最后返回bean1</li><li>我的问题是既然bean都持有了其他ILogicChain接口的bean（相当于有了指针），那这个bean就不再是无状态的了，线程1调用openLogicChain(10001),ruleModels(1,2,3)，返回的是链表1-&gt;2-&gt;3-&gt;default,这时候线程2调用openLogicChain(10002),ruleModels(2,4,6),那线程1持有的链表就变成了1-&gt;2-&gt;4-&gt;6-&gt;default 还有就是logicChainGroup.get(ruleModels[0])获取的是单例的吗，每次调用获取的似乎并不是同一个bean实例</li></ol><p><strong>解决</strong></p><p>最初使用的Bean的默认作用域是单例模式，因此会出现上述问题。 后面添加了@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)这个注解， 每次请求该Bean时，Spring容器都会创建一个新的实例，算是spring内置的原型模式应用。 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)是Spring框架中的一个注解，用于指定Bean的作用域为原型模式（prototype）。在Spring IoC容器中，Bean的默认作用域是单例模式（singleton），即在整个应用中只有一个实例。而原型模式则意味着每次请求该Bean时，Spring容器都会创建一个新的实例。</p><h4 id="http401未授权错误" tabindex="-1"><a class="header-anchor" href="#http401未授权错误"><span>HTTP401未授权错误</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">org.springframework.web.reactive.function.client.WebClientResponseException$Unauthorized: </span>
<span class="line">401 Unauthorized from POST https://apis.itedus.cn/v1/chat/completions</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>调用外部接口返回了 HTTP 401 未授权错误。这不是 Reactor 自身的 bug，而是因为你请求第三方 API 时，鉴权不通过。</p><p>查找检查发现项目使用的是Spring AI 1.0.0-M8版本，在早期版本中，OpenAiApi可能不会自动在API密钥前添加&#39;Bearer &#39;前缀。我需要修改AiClientModelNode.java文件，确保Authorization头格式正确。</p><p>修改了 AiClientModelNode.java 文件中的 createOpenAiChatModel 方法，添加了代码来检查和确保API密钥以&#39;Bearer &#39;前缀开头：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">    // 构建OpenAiApi</span>
<span class="line">    String apiKey = modelVO.getApiKey();</span>
<span class="line">    // 确保API密钥以Bearer开头（Spring AI 1.0.0-M8版本需要手动添加）</span>
<span class="line">    if (apiKey != null &amp;&amp; !apiKey.startsWith(&quot;Bearer &quot;)) {</span>
<span class="line">        apiKey = &quot;Bearer &quot; + apiKey;</span>
<span class="line">    }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="找不到bean" tabindex="-1"><a class="header-anchor" href="#找不到bean"><span>找不到bean</span></a></h4><p>实现类没加Service 如果实现类继承另一个抽象类,要加最终实现类上面。</p><h3 id="压测" tabindex="-1"><a class="header-anchor" href="#压测"><span>压测</span></a></h3><p>单机TPS：600，RT:300ms。</p><p>三台4c8g100M服务器，一台部署项目、一台部署中间件（redis、mysql）、一台部署监控和jmeter 插入20w用户，删除非错误日志打印</p><p><strong>yml配置</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">server:</span>
<span class="line">  port:8081</span>
<span class="line">  tomcat:mbeanregistry:</span>
<span class="line">    enanbled:true</span>
<span class="line">  max-connections:20000</span>
<span class="line">  threads:</span>
<span class="line">    max:800 # 设定处理客户请求的线程的最大数目，决定了服务器可以同时响应客户请求的数,默认200</span>
<span class="line">    min-spare:200 #初始化线程数，默认为10</span>
<span class="line">  accept-count:1000 #等待队列长度</span>
<span class="line">  </span>
<span class="line">  ...</span>
<span class="line">  </span>
<span class="line">        db00:</span>
<span class="line">        driver-class-name: com.mysql.cj.jdbc.Driver</span>
<span class="line">        url: jdbc:mysql://127.0.0.1:13306/big_market?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=UTC&amp;useSSL=true</span>
<span class="line">        username: root</span>
<span class="line">        password: 123456</span>
<span class="line">        type-class-name: com.zaxxer.hikari.HikariDataSource</span>
<span class="line">        pool:</span>
<span class="line">          pool-name: Retail_HikariCP</span>
<span class="line">          minimum-idle: 20 #最小空闲连接数量</span>
<span class="line">          idle-timeout: 180000 #空闲连接存活最大时间，默认600000（10分钟）</span>
<span class="line">          maximum-pool-size: 30 #连接池最大连接数，默认是10</span>
<span class="line">          auto-commit: true  #此属性控制从池返回的连接的默认自动提交行为,默认值：true</span>
<span class="line">          max-lifetime: 1800000 #此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟</span>
<span class="line">          connection-timeout: 30000 #数据库连接超时时间,默认30秒，即30000</span>
<span class="line">          connection-test-query: SELECT 1</span>
<span class="line">      db01:</span>
<span class="line">        driver-class-name: com.mysql.cj.jdbc.Driver</span>
<span class="line">        url: jdbc:mysql://127.0.0.1:13306/big_market_01?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=UTC&amp;useSSL=true</span>
<span class="line">        username: root</span>
<span class="line">        password: 123456</span>
<span class="line">        type-class-name: com.zaxxer.hikari.HikariDataSource</span>
<span class="line">        pool:</span>
<span class="line">          pool-name: Retail_HikariCP</span>
<span class="line">          minimum-idle: 20 #最小空闲连接数量</span>
<span class="line">          idle-timeout: 180000 #空闲连接存活最大时间，默认600000（10分钟）</span>
<span class="line">          maximum-pool-size: 150 #连接池最大连接数，默认是10</span>
<span class="line">          auto-commit: true  #此属性控制从池返回的连接的默认自动提交行为,默认值：true</span>
<span class="line">          max-lifetime: 1800000 #此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟</span>
<span class="line">          connection-timeout: 30000 #数据库连接超时时间,默认30秒，即30000</span>
<span class="line">          connection-test-query: SELECT 1</span>
<span class="line">      db02:</span>
<span class="line">        driver-class-name: com.mysql.cj.jdbc.Driver</span>
<span class="line">        url: jdbc:mysql://127.0.0.1:13306/big_market_02?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;serverTimezone=UTC&amp;useSSL=true</span>
<span class="line">        username: root</span>
<span class="line">        password: 123456</span>
<span class="line">        type-class-name: com.zaxxer.hikari.HikariDataSource</span>
<span class="line">        pool:</span>
<span class="line">          pool-name: Retail_HikariCP</span>
<span class="line">          minimum-idle: 20 #最小空闲连接数量</span>
<span class="line">          idle-timeout: 180000 #空闲连接存活最大时间，默认600000（10分钟）</span>
<span class="line">          maximum-pool-size: 150 #连接池最大连接数，默认是10</span>
<span class="line">          auto-commit: true  #此属性控制从池返回的连接的默认自动提交行为,默认值：true</span>
<span class="line">          max-lifetime: 1800000 #此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟</span>
<span class="line">          connection-timeout: 30000 #数据库连接超时时间,默认30秒，即30000</span>
<span class="line">          connection-test-query: SELECT 1</span>
<span class="line">   ...</span>
<span class="line">   </span>
<span class="line">  redis:</span>
<span class="line">  sdk:</span>
<span class="line">    config:</span>
<span class="line">      host: 127.0.0.1</span>
<span class="line">      port: 16379</span>
<span class="line">      pool-size: 10</span>
<span class="line">      min-idle-size: 20</span>
<span class="line">      idle-timeout: 30000</span>
<span class="line">      connect-timeout: 10000</span>
<span class="line">      retry-attempts: 5</span>
<span class="line">      retry-interval: 1000</span>
<span class="line">      ping-interval: 60000</span>
<span class="line">      keep-alive: true       </span>
<span class="line">   </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程池参数</p><table><thead><tr><th>应用名称</th><th>线程池名称</th><th>核心线程池数</th><th>最大线程数</th><th>当前活跃线程数</th><th>当前池中线程数</th></tr></thead><tbody><tr><td>big-market-app</td><td>database_sharding</td><td>20</td><td>50</td><td>0</td><td>20</td></tr><tr><td>big-market-app</td><td>asynchronous_send_mq</td><td>20</td><td>50</td><td>0</td><td>0</td></tr><tr><td>big-market-app</td><td>multiple_draw</td><td>20</td><td>50</td><td>0</td><td>0</td></tr></tbody></table><blockquote><p><strong>注意</strong>：在使用 Docker 容器部署应用时，无法正常监控到带有 @Timed 注解标记的方法（通常是用于统计方法执行时间等指标），因此将部署方式改为直接通过 java -jar 命令运行 jar 包的方式（非容器化部署），以解决 @Timed 注解相关的监控问题。</p></blockquote><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">JAVA_OPTS=&quot;-Xms6144m -Xmx6144m -Xmn4096m -XX:MaxMetaspaceSize=256m -XX:MetaspaceSize=256m&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>-Xms6144m：设置 JVM 的初始堆内存大小为 6144MB（即 6GB）。初始堆内存是程序启动时 JVM 向操作系统申请的内存量，避免程序运行中频繁申请内存影响性能。</li><li>-Xmx6144m：设置 JVM 的最大堆内存大小为 6144MB（即 6GB）。堆内存是 JVM 用于存储对象实例的主要区域，最大堆内存限制了 JVM 能使用的堆内存上限，防止内存占用无限增长。</li><li>-Xmn4096m：设置新生代（Young Generation）的内存大小为 4096MB（即 4GB）。堆内存分为新生代和老年代，新生代用于存放新创建的对象，此参数直接指定新生代大小，剩余的堆内存（6144m - 4096m = 2048m）会分配给老年代。</li><li>-XX:MaxMetaspaceSize=256m：设置元空间（Metaspace）的最大大小为 256MB。元空间用于存储类的元数据（如类结构、方法信息等），属于本地内存（非堆内存），此参数限制元空间的最大占用量。</li><li>-XX:MetaspaceSize=256m：设置元空间的初始大小为 256MB。元空间的初始大小决定了 JVM 首次为元数据分配的内存量，后续会根据需要动态调整（但不超过MaxMetaspaceSize的限制）。</li></ul><h4 id="第一次压测" tabindex="-1"><a class="header-anchor" href="#第一次压测"><span>第一次压测</span></a></h4><p>设置Ramp-Up 为线程数的 1 / 10； 循环次数 200 <img src="`+h+'" alt="img_66.png"></p><p><strong>压测结果</strong><img src="'+g+'" alt="img_67.png"></p><ol><li>TPS（吞吐量） <ul><li>TPS 在 419.4/sec（100线程） → 600.7/sec（300线程） → 570/sec（800线程） 之间波动。</li><li>峰值出现在 300线程，TPS ≈ 600/sec。</li><li>之后随着线程数增加，TPS 没有继续提升，甚至略有下降，说明系统已达到 性能瓶颈（CPU/Redis/MySQL/网络带宽等可能成为瓶颈）。</li></ul></li><li>RT（响应时间） <ul><li>平均 RT 从 199ms（100线程）逐步上升到 1008ms（800线程）。</li><li>中位 RT 在高并发下接近平均值，说明响应时间分布相对稳定。</li><li>90%~99%分位数 RT 提示了长尾请求延迟： 300线程时 99分位 1238ms，800线程时 99分位 2537ms，最大值甚至达到 23644ms（23s+），说明在极端情况下有请求严重超时。</li></ul></li></ol><p>系统在 300线程左右 时 TPS 达到峰值（约 600/sec），RT 平均 357ms，性能最佳。 超过 300线程后，TPS 并未增加，RT 却显著上升，说明瓶颈已出现。例如数据库的插入/查询操作， 缓存的热点key/慢查询。网络带宽和CPU核心数</p><p>优化建议：</p><ul><li>增加服务节点（应用和数据库的水平扩展）。</li><li>优化数据库读写，启用读写分离或连接池优化。</li><li>检查 GC 日志，避免频繁 Full GC。</li><li>使用链路追踪（如 SkyWalking）定位耗时最长的环节。</li></ul><h4 id="第二次压测" tabindex="-1"><a class="header-anchor" href="#第二次压测"><span>第二次压测</span></a></h4><p><img src="'+v+'" alt="img_68.png"></p><p><strong>压测结果</strong><img src="'+b+'" alt="img_69.png"> 系统的最大 TPS 大约 500~520/sec，并发增加到 250线程以后，TPS 不再提升，进入瓶颈状态。 平均 RT 从 143ms 增长到 600ms，符合预期。 长尾延迟（99%分位）超过 1.5s，需要关注极端用户体验。</p><h4 id="第三次压测" tabindex="-1"><a class="header-anchor" href="#第三次压测"><span>第三次压测</span></a></h4><p>设置db01 db02 最大 400， redis 最大 100； <img src="'+y+'" alt="img_70.png"><img src="'+f+'" alt="img_71.png"><strong>压测结果</strong><img src="'+x+'" alt="img_72.png"><img src="'+S+'" alt="img_73.png"><img src="'+D+'" alt="img_74.png"><img src="'+k+'" alt="img_75.png"><img src="'+T+'" alt="img_76.png"><img src="'+I+'" alt="img_77.png"></p><ol><li><strong>TPS</strong>:TPS ≈ 608/sec，比你之前 200线程压测（≈516/sec）有明显提升，说明 连接池配置调整（DB400/Redis100）起到了优化作用。不过RT也增加了。 <ul><li>Mysql（db01/db02 最大连接设 400 ）：压测中未达连接数上限（从 “数据库监控” 面板看，连接数峰值远低于 400 ），数据库连接池未成为 TPS 瓶颈。</li><li>服务器带宽 100M，压测中 接收/发送 KB/s 峰值约 205.47/146.89 KB/s（首面板 draw-300 ），换算成网络带宽占比极低（(205+147)*8/100/1024 ≈ 3% ），网络不是 TPS 瓶颈。</li><li>JVM 线程、Tomcat 连接数未超限（Tomcat 最大连接设 800，实时连接数峰值在 200 内 ），应用容器可支撑当前 TPS。</li><li>Mysql 虽未打满连接，但需结合 “SQL 执行耗时”（如下文 RT 分析 ）判断是否有慢查询；Redis 若为纯缓存场景，当前 TPS 下响应很快（无明显阻塞 ）。</li></ul></li><li><strong>RT</strong>:平均值为318ms，90% 响应时间 539 ms、95% 700 ms、99% 1181 ms（长尾部分 ）。 最小值 95 ms、最大值 4238 ms（存在偶发毛刺 ）。 <ul><li>初始化阶段（20:05 前）：Jmeter 线程启动、业务缓存预热（如首单查询 DB 加载字典 ），RT 从 95 ms 逐步爬升，属正常 “冷启动” 波动。</li><li>稳态阶段（20:05–20:15 ）：RT 稳定在 300–400 ms（90% 分位数 539 ms 接近均值 ），说明 业务逻辑 + 中间件 + 网络在稳态下协同较好。</li><li>毛刺阶段（20:15 附近）： <ul><li>从 “执行抽奖 - 响应时间” 面板看，draw 接口有 200 ms 级毛刺；“保存用户奖励记录” 也有突刺。结合 JVM-GC 监控（GC Stop the World Duration 有 3-10 ms 级波动 ），推测是 新生代 GC 触发（PS Eden Space 有频繁分配 / 回收 ），短暂暂停业务线程导致 RT 突刺。</li><li>若毛刺频率低（如 1 次 / 分钟 ），对整体 RT 影响可控；若高频出现，需优化 JVM 堆配置（如增大 Eden 区、调整 MaxTenuringThreshold ）。</li></ul></li></ul></li></ol><ul><li>CPU 使用率：系统 CPU 均值 61.8%（System CPU Usage ），进程 CPU 接近系统 CPU（Process CPU Usage ≈ 61.1% ），说明 应用进程是 CPU 主要消耗者，但未达 100% 饱和（4C 服务器，单进程 CPU 占比 60%+ 仍有裕量 ）。</li><li>Load Average：1 分钟负载 27.7（Load Average [1m]=27.7 ），4C 服务器下 Load &gt; 4 需关注，但结合 CPU 未打满，说明 存在线程等待（如 IO 阻塞 ），需看 Mysql/Redis 的慢操作。</li><li>堆内存：PS Eden Space（新生代 ）波动大，PS Old Gen（老年代 ）稳定在 2.33 GB（远低于 Xmx=6144m ），说明 对象多在新生代回收，老年代未积累压力。</li><li>GC 频率：Minor GC 频繁（GC Count 有波动 ），但 STW 时间 短（多数在 10 ms 内 ），对 RT 影响集中在 “毛刺” 点，可通过 增大新生代内存（-Xmn ） 或 优化对象创建逻辑（减少临时对象 ） 优化。</li></ul><p>user_award_record 插入有唯一键冲突（日志里的 DuplicateKeyException ），虽已过滤错误日志，但 实际插入失败会导致业务回滚 / 重试，间接拉高 RT 均值（若有重试逻辑，需看 draw 接口的 99% 分位数 是否因重试放大 ）。</p><blockquote><p>针对唯一键冲突问题，可以采用改用雪花算法生成 order_id； 插入时用 INSERT IGNORE/ON DUPLICATE KEY UPDATE 避免抛异常。</p></blockquote><p>考虑补充 redis-cli monitor 或接入 Redis 监控平台，观察 GET/SET 等命令的耗时分布。</p><h3 id="扩展和优化思路" tabindex="-1"><a class="header-anchor" href="#扩展和优化思路"><span>扩展和优化思路</span></a></h3><p>补库存，decr 修改为 incr，通过操作数据库添加库存，之后发mq，接收后通过incrby + setnx 或lua脚本加库存。通过可以对失败的进行记录。之后使用 incr 和总量 + 失败量对比。</p><p>对于奖品和任务记录插入的唯一索引id，项目中使用 RandomStringUtils.randomNumeric(12) 生成12位随机数字作为 order_id。 还可以通过雪花算法（Snowflake）：生成 64 位全局唯一 ID，包含时间戳、机器 ID、序列号，适合分布式系统；</p><ul><li>Redis 集群模式下存在主从同步延迟风险， 引入 RedLock 算法：通过 Redis 集群多节点锁竞争实现更高可靠的分布式锁，避免单点故障。</li><li>万分位以下概率抽奖使用 O(1)缓存方案，但高并发下 Redis 内存压力大；高概率抽奖采用循环对比效率低。对高概率奖品区间进行二进制分段压缩（如将 10000 次抽奖压缩为 100 个区间），减少循环次数。</li><li>当前仅依赖日志分析，缺乏分布式追踪能力。 SkyWalking 集成：通过 OpenTelemetry 协议采集链路数据，实现请求耗时、异常热点分析。</li><li>抽奖结果依赖异步消息，用户无法实时感知状态。 WebSocket 推送：通过 WebSocket 实时推送抽奖结果，减少页面轮询。 在抽奖页面增加抽奖结果记录展示。</li><li>增加连抽功能，例如十连抽，前端增加十连抽按钮，十连抽最终停止在最优奖励上。</li></ul>',150)]))}const w=e(R,[["render",C]]),B=JSON.parse('{"path":"/blogs/Project/dayingxiao/dayingxiao4.html","title":"幸运营销汇-开发总结","lang":"en-US","frontmatter":{"title":"幸运营销汇-开发总结","date":"2025/08/18","tags":["DDD","前后端分离","微服务","SpringBoot","MyBatis","MySQL","Redis","RabbitMQ","Docker"],"categories":["后端开发"]},"headers":[{"level":3,"title":"难点及解决","slug":"难点及解决","link":"#难点及解决","children":[]},{"level":3,"title":"整体流程图","slug":"整体流程图","link":"#整体流程图","children":[]},{"level":3,"title":"行为驱动的数据库表er图","slug":"行为驱动的数据库表er图","link":"#行为驱动的数据库表er图","children":[]},{"level":3,"title":"业务架构图","slug":"业务架构图","link":"#业务架构图","children":[]},{"level":3,"title":"应用架构图","slug":"应用架构图","link":"#应用架构图","children":[]},{"level":3,"title":"部署架构图","slug":"部署架构图","link":"#部署架构图","children":[]},{"level":3,"title":"bug及解决","slug":"bug及解决","link":"#bug及解决","children":[]},{"level":3,"title":"压测","slug":"压测","link":"#压测","children":[]},{"level":3,"title":"扩展和优化思路","slug":"扩展和优化思路","link":"#扩展和优化思路","children":[]}],"git":{"createdTime":1753683193000,"updatedTime":1755092504000,"contributors":[{"name":"zxy","email":"431559981@qq.com","commits":2},{"name":"zxy","email":"zxy0613zxy@outlook.com","commits":2}]},"filePathRelative":"blogs/Project/dayingxiao/dayingxiao4.md"}');export{w as comp,B as data};
