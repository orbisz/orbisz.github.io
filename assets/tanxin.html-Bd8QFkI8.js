import{_ as a,c as p,a as r,b as l,d as t,e as i,r as o,o as s}from"./app-CwN1xCkZ.js";const d={},u={href:"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?envType=study-plan-v2&envId=top-100-liked",target:"_blank",rel:"noopener noreferrer"},h={href:"https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&envId=top-100-liked",target:"_blank",rel:"noopener noreferrer"},c={href:"https://leetcode.cn/problems/partition-labels/?envType=study-plan-v2&envId=top-100-liked",target:"_blank",rel:"noopener noreferrer"},m={href:"https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked",target:"_blank",rel:"noopener noreferrer"},v={href:"https://leetcode.cn/problems/perfect-squares/?envType=study-plan-v2&envId=top-100-liked",target:"_blank",rel:"noopener noreferrer"},b={href:"https://leetcode.cn/problems/coin-change/?envType=study-plan-v2&envId=top-100-liked",target:"_blank",rel:"noopener noreferrer"},f={href:"https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked",target:"_blank",rel:"noopener noreferrer"};function k(g,e){const n=o("ExternalLinkIcon");return s(),p("div",null,[e[7]||(e[7]=r('<h2 id="贪心算法" tabindex="-1"><a class="header-anchor" href="#贪心算法"><span>贪心算法</span></a></h2><p>贪心法是一种求解最优化问题的算法设计策略，有时也可以用来单单找可行解。贪心法是通过分布决策的方法来求解问题的，在每一步选择中都采取当前状态下最优（局部最优）的选择，从而希望导致全局结果也最优的算法策略。通常只考虑局部最优性</p><p>问题的全局最优解可以通过一系列局部最优选择得到。即每一步的选择都是当前状态下的最优选择，且不会影响后续步骤的选择。 问题的最优解包含其子问题的最优解。通过解决子问题的最优解，可以递推得到原问题的最优解。</p><h3 id="基本步骤" tabindex="-1"><a class="header-anchor" href="#基本步骤"><span>基本步骤</span></a></h3><ul><li>贪心选择性质：局部最优能导出全局最优。</li><li>最优子结构：问题的整体最优解包含子问题的最优解</li></ul><p>适用于可以用“当前最优”构建“全局最优”的问题</p><h3 id="算法流程" tabindex="-1"><a class="header-anchor" href="#算法流程"><span>算法流程</span></a></h3><p>1.定义贪心选择规则</p><ul><li>明确每一步中如何选择当前状态下的“最优决策”（如选最大值、最早结束、最小代价等）</li></ul><p>2.判断贪心选择性质和最优子结构</p><ul><li>验证局部最优是否能导出全局最优（即贪心是否适用）</li><li>确认当前选择不会影响后续决策空间（无后效性）</li></ul><p>3.初始化问题状态</p><ul><li>初始化记录变量（如最远可达位置、当前覆盖范围、当前时间等）</li></ul><p>4.按照策略遍历或排序</p><ul><li>若需要排序，则按贪心标准排序（如按结束时间、单位价值等）</li><li>按顺序遍历每个元素，依次做出贪心决策并更新状态</li></ul><p>5.返回目标结果</p><ul><li>根据问题目标返回布尔值、计数值、最优路径等结果</li></ul><h3 id="例题" tabindex="-1"><a class="header-anchor" href="#例题"><span>例题</span></a></h3>',18)),l("p",null,[l("a",u,[e[0]||(e[0]=t("买卖股票的最佳时机")),i(n)])]),l("p",null,[l("a",h,[e[1]||(e[1]=t("跳跃游戏")),i(n)])]),l("p",null,[l("a",c,[e[2]||(e[2]=t("划分字母区间")),i(n)])]),e[8]||(e[8]=r('<h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span>动态规划</span></a></h2><p>将复杂问题分解成子问题，保存子问题的解来避免重复计算，从而获得整体最优解的算法思想。</p><h3 id="基本思想" tabindex="-1"><a class="header-anchor" href="#基本思想"><span>基本思想</span></a></h3><ul><li>最优子结构：整体问题的最优解可以通过子问题的最优解组合得到。</li><li>重叠子问题：子问题之间有重复，可以缓存。</li><li>无后效性：状态只与当前有关，历史状态无影响。</li></ul><p>适用问题需要具有以下三个特性：</p><ul><li>重叠子问题（重复计算）</li><li>最优子结构（子问题可以递推）</li><li>状态可表示（一般数组或二维数组表示）</li></ul><h3 id="算法流程-1" tabindex="-1"><a class="header-anchor" href="#算法流程-1"><span>算法流程</span></a></h3><p>1.定义状态</p><ul><li>明确“子问题”是什么，即： <ul><li>dp[i] 是什么含义？</li></ul></li><li>若问题有多个维度（如重量和物品编号），可以用二维或多维 dp 数组。</li></ul><p>2.确定状态转移方程（核心）</p><ul><li>分析第 i 个位置/元素是如何由前面的状态推导出来的， 找出转移公式。</li><li></li></ul><p>3.初始化边界条件</p><ul><li>设置初始状态（如 dp[0]、dp[1]）</li><li>边界状态代表最小输入规模的已知结果</li></ul><p>3.确定遍历顺序</p><ul><li>一维时：正序或倒序（如 0/1 背包需要倒序避免重复选）</li><li>多维时：决定嵌套循环的顺序</li><li>遍历顺序必须匹配状态转移逻辑，保证前置状态先于当前状态计算完成</li></ul><p>4.返回结果</p><ul><li>根据题目要求返回最终状态值</li></ul><h3 id="例题-1" tabindex="-1"><a class="header-anchor" href="#例题-1"><span>例题</span></a></h3>',18)),l("p",null,[l("a",m,[e[3]||(e[3]=t("打家劫舍")),i(n)])]),l("p",null,[l("a",v,[e[4]||(e[4]=t("完全平方数")),i(n)])]),l("p",null,[l("a",b,[e[5]||(e[5]=t("零钱兑换")),i(n)])]),l("p",null,[l("a",f,[e[6]||(e[6]=t("乘积最大子数组")),i(n)])]),e[9]||(e[9]=l("p",null,[l("a",{href:""})],-1)),e[10]||(e[10]=l("p",null,[l("strong",null,"贪心抓眼前，快而不一定最优； 动态思全局，慢但保最优解； 能贪心就贪，不能贪就动态规划")],-1))])}const y=a(d,[["render",k]]),_=JSON.parse('{"path":"/blogs/algorithm/tanxin.html","title":"贪心算法和动态规划详解","lang":"en-US","frontmatter":{"title":"贪心算法和动态规划详解","date":"2024/04/19","tags":["Java"],"categories":["算法"]},"headers":[{"level":2,"title":"贪心算法","slug":"贪心算法","link":"#贪心算法","children":[{"level":3,"title":"基本步骤","slug":"基本步骤","link":"#基本步骤","children":[]},{"level":3,"title":"算法流程","slug":"算法流程","link":"#算法流程","children":[]},{"level":3,"title":"例题","slug":"例题","link":"#例题","children":[]}]},{"level":2,"title":"动态规划","slug":"动态规划","link":"#动态规划","children":[{"level":3,"title":"基本思想","slug":"基本思想","link":"#基本思想","children":[]},{"level":3,"title":"算法流程","slug":"算法流程-1","link":"#算法流程-1","children":[]},{"level":3,"title":"例题","slug":"例题-1","link":"#例题-1","children":[]}]}],"git":{"createdTime":1749459287000,"updatedTime":1754659489000,"contributors":[{"name":"zxy","email":"zxy0613zxy@outlook.com","commits":2}]},"filePathRelative":"blogs/algorithm/tanxin.md"}');export{y as comp,_ as data};
