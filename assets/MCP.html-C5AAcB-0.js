import{_ as s,c as e,a,o as t}from"./app-ByLG9LQz.js";const p="/assets/img_19-Ba0-6sXV.png",o="/assets/img_20-CFk1yAOA.png",l={};function i(c,n){return t(),e("div",null,n[0]||(n[0]=[a(`<h2 id="mcp" tabindex="-1"><a class="header-anchor" href="#mcp"><span>MCP</span></a></h2><p>MCP（模型上下文协议）是规范应用程序向大语言模型提供上下文的开放协议，旨在通过标准化的方式将LLM与外部工具与系统集成。MCP本质上是MCP Client和MCP Server之间的通信协议，实现了Agent开发与工具开发的解耦。</p><p>由三个核心组件组成：</p><ol><li><code>MCP Client</code>：负责发送请求/接收响应，一般直接集成在<code>MCP Host</code>中。</li><li><code>MCP Server</code>：处理请求并返回上下文数据，例如高德、<code>GitHub MCP</code>工具等，可以在<code>MCP Host</code>直接调用。</li><li><code>MCP Host</code>：<code>MCP</code>协议的执行者。负责：接受用户问题 → 选择工具 → 构建参数 → 通过<code>Client</code>调用<code>Server</code> → 解析结果 → 继续对话</li></ol><blockquote><p>集成<code>MCP Client</code>的智能体执行平台（如 <code>IDEA LAB</code>）或模型厂商的 <code>Agent/AI</code> 客户端（如 <code>Cherry Studio</code>）均可承担<code>MCP Host</code>职能。例如阿里云百炼平台上的智能体应用。</p></blockquote><p>当所有的<code>Agent/AI</code>客户端集成了<code>MCP Client</code>，并且通过MCP协议去实现调用<code>MCP Server</code>提供的工具，从Agent开发的角度来说，MCP就变成了一个Agent进行<code>function call</code>的协议了， 如果大家都按MCP的方式去给Agent添加工具，不就是统一了<code>function call</code>吗？所以如果把Agent比作手机，接口比作充电线，那MCP Server牌充电线就相当于Type-C接口类型的充电线。</p><h3 id="mcp解决的核心问题" tabindex="-1"><a class="header-anchor" href="#mcp解决的核心问题"><span>MCP解决的核心问题</span></a></h3><p><span style="color:#ff6600;">1. 让模型调用接口更简单，把接口上下文一键喂给LLM</span></p><p>有了统一协议，通义千问、IDEA LAB等平台的AI客户端（MCP Host）内置<code>MCP Client</code>，按协议进行通信，我们只需要把自己的接口封装成<code>MCP Server</code>，接入平台即可；选工具、拼参数、调接口、解析结果等链路由平台自动完成。</p><p><span style="color:#ff6600;">2. 实现了Agent开发与工具开发的解耦</span></p><p>所有平台支持MCP协议后，工具按<code>MCP Server</code>标准发布，Agent即可直接调用，无需再关心&quot;选-拼-调-解&quot;全流程，真正做到工具开发与Agent开发分离。</p><h3 id="mcp技术原理深度解析" tabindex="-1"><a class="header-anchor" href="#mcp技术原理深度解析"><span>MCP技术原理深度解析</span></a></h3><p><span style="color:#ff6600;">1. SSE（Server-Sent Events）：MCP Client和MCP Server之间的数据传输方式</span></p><p>SSE全称Server-Sent Events，是一种基于HTTP协议实现的Web技术，专门用于服务器向客户端实时推送数据。它通过建立持久的HTTP连接，让客户端监听事件流，从而实时接收服务器推送的数据。</p><p><strong>sse是如何做到实时推送的</strong></p><p>SSE采用了一种巧妙地变通方法：虽然底层仍然是请求-响应模式，但相应的不是一个简单的数据包，而是一个持续不断的流信息（stream）。就像是一次耗时很长的下载过程，让数据源源源不断的流向客户端。 并且因为SSE基于HTTP实现，所以浏览器天然支持这一技术，无需额外配置。</p><p>因此，在 MCP 体系里，SSE 就是&quot;用一次超长时间的 HTTP 下载&quot;来伪装成服务器主动推送；规范极简（4 个固定字段），浏览器原生支持，Spring 既可用同步阻塞的<code>SseEmitter</code>，也可用响应式的<code>Flux&lt;ServerSentEvent&gt;</code>实现。</p><h4 id="_1-sse在mcp中的定位" tabindex="-1"><a class="header-anchor" href="#_1-sse在mcp中的定位"><span>1. SSE在MCP中的定位</span></a></h4><p>实现MCP Server → MCP Client 的单向实时数据流，解决「怎么传」.</p><p>本质：</p><ul><li>依旧走 HTTP/1.1，复用现有基础设施；</li><li>长连接 + <code>text/event-stream</code>响应，把&quot;请求-响应&quot;拉成&quot;长时间下载&quot;。</li></ul><h4 id="_2-协议格式" tabindex="-1"><a class="header-anchor" href="#_2-协议格式"><span>2. 协议格式</span></a></h4><p><strong>Header</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Content-Type: text/event-stream</span>
<span class="line">Cache-Control: no-cache</span>
<span class="line">Connection: keep-alive</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Body</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">field: value\\n\\n              /* 每条消息以两个换行结束 */</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>服务器发送给浏览器的body必须符合上述k-v格式，其中field的类型是固定的四种字段：</p><ul><li><code>data</code>实际负载</li><li><code>id</code>事件序号，断线续传用</li><li><code>event</code>事件类型，前端<code>addEventListener(&#39;event名&#39;)</code></li><li><code>retry</code>断线重连间隔（ms）</li></ul><h4 id="_3-实现方式" tabindex="-1"><a class="header-anchor" href="#_3-实现方式"><span>3. 实现方式</span></a></h4><p><strong>Spring MVC（阻塞式）</strong></p><p>通过返回一个SseEmitter对象作为事件发射器给前端，然后我们在后端调用emitter.send()方法发送的数据会被封装成SSE事件流的形式，前端可以通过监听该事件流来进行数据更新。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">&quot;/stock-price&quot;</span><span class="token punctuation">,</span> produces<span class="token operator">=</span><span class="token constant">TEXT_EVENT_STREAM_VALUE</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">SseEmitter</span> <span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    </span>
<span class="line">    <span class="token class-name">SseEmitter</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SseEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span>
<span class="line">    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        </span>
<span class="line">        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            </span>
<span class="line">            e<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">SseEmitter</span><span class="token punctuation">.</span><span class="token function">event</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            </span>
<span class="line">            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </span>
<span class="line">        <span class="token punctuation">}</span>    </span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span>
<span class="line">    <span class="token keyword">return</span> e<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前端在js中通过<code>new EventSource</code>建立一个<code>EventSource</code>对象，它会与<code>&quot;/stock-price&quot;</code>这个路径建立sse长连接，并监听事件。当后端发送event事件以后，会触发<code>eventSource.onmessage</code>这个回调函数，将数据写入到页面中。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">const es = new EventSource(&quot;/stock-price&quot;);</span>
<span class="line">es.onmessage = e =&gt; document.body.innerText = e.data;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Spring WebFlux（响应式）</strong></p><p>返回publisher给到前端进行订阅，然后我们在后端通过<code>Sinks.Many&lt;ServerSentEvent&lt;?&gt;&gt;</code>这个类的<code>tryEmitNext</code>方法来手动发送事件给到前端，前端可以通过监听该事件流来进行数据更新。</p><div class="language-JAVA line-numbers-mode" data-highlighter="prismjs" data-ext="JAVA" data-title="JAVA"><pre><code><span class="line">@GetMapping(&quot;/stream-sse&quot;)</span>
<span class="line">public Flux&lt;ServerSentEvent&lt;String&gt;&gt; stream() {</span>
<span class="line">    return Flux.interval(Duration.ofSeconds(1))</span>
<span class="line">        .map(i -&gt; ServerSentEvent.builder()</span>
<span class="line">            .id(i.toString())</span>
<span class="line">            .event(&quot;tick&quot;)</span>
<span class="line">            .data(&quot;now=&quot; + LocalTime.now())</span>
<span class="line">            .build());</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前端同上。</p><p><span style="color:#ff6600;">2. JSON-RPC 2.0：MCP Client和MCP Server之间的传输的内容格式</span> JSON-RPC 2.0 是一种无状态、轻量级的远程过程调用(RPC)协议，定义了MCP Client和MCP Server之间进行通信的格式。JSON-RPC 2.0协议定义了请求和响应的格式，以及错误处理机制。</p><p>在MCP里，Client与 Server永远只交换一条&quot;四字段&quot; JSON-RPC 2.0 消息：</p><ul><li>版本<code>jsonrpc</code>：协议版本号</li><li>方法<code>method</code>：远端要执行的函数名</li><li>编号<code>id</code>：客户端生成的请求匹配符，无<code>id</code>视为通知，不期待回复</li><li>载荷<code>params</code>：入参</li><li><code>result|error</code>：成果返回<code>result</code>，失败返回<code>error</code></li></ul><p>定义MCP Server和MCP Client之间的统一的无状态消息格式，解决「说什么」。本质上是通过无状态、轻量级的四字段JSON契约，实现两端零差异解析。</p><h4 id="完整范式" tabindex="-1"><a class="header-anchor" href="#完整范式"><span>完整范式</span></a></h4><ol><li>请求</li></ol><div class="language-json line-numbers-mode" data-highlighter="prismjs" data-ext="json" data-title="json"><pre><code><span class="line"><span class="token punctuation">{</span> <span class="token property">&quot;jsonrpc&quot;</span><span class="token operator">:</span> <span class="token string">&quot;2.0&quot;</span><span class="token punctuation">,</span> <span class="token property">&quot;method&quot;</span><span class="token operator">:</span> <span class="token string">&quot;...&quot;</span><span class="token punctuation">,</span> <span class="token property">&quot;params&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>...<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> &lt;unique&gt; <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>响应</li></ol><div class="language-json line-numbers-mode" data-highlighter="prismjs" data-ext="json" data-title="json"><pre><code><span class="line"><span class="token punctuation">{</span> <span class="token property">&quot;jsonrpc&quot;</span><span class="token operator">:</span> <span class="token string">&quot;2.0&quot;</span><span class="token punctuation">,</span> <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> &lt;same&gt;<span class="token punctuation">,</span> <span class="token property">&quot;result&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>...<span class="token punctuation">}</span> <span class="token punctuation">}</span>   <span class="token comment">// 成功</span></span>
<span class="line"><span class="token punctuation">{</span> <span class="token property">&quot;jsonrpc&quot;</span><span class="token operator">:</span> <span class="token string">&quot;2.0&quot;</span><span class="token punctuation">,</span> <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> &lt;same&gt;<span class="token punctuation">,</span> <span class="token property">&quot;error&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>code<span class="token punctuation">,</span> message<span class="token punctuation">,</span> data?<span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token comment">// 失败</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><span style="color:#ff6600;">3. MCP协议：MCP Client和MCP Server之间的通信（调用）协议</span></p><p>MCP本质上是MCP Client和MCP Server之间的通信协议</p><ol><li>定义了MCP Server和MCP Client之间的连接建立过程；</li><li>定义了MCP Client和MCP Server之间如何进行信息（上下文）交换;</li><li>定义了MCP Client和MCP Server之间如何连接关闭过程；</li></ol><p>MCP协议就是“客户端先拉一条SSE长连接通知，再用普通HTTP POST 发请求到服务端；Client和Server之间必须先发 initialize 打招呼，才能调工具，最后Client关 SSE 就通信结束了&quot;。</p><p><strong>定位</strong>：在 SSE + JSON-RPC 2.0 之上，定义 两通道、四步骤、全生命周期 的MCP Server与 MCP Client 通信协议</p><p><strong>本质</strong>：把&quot;怎么连、怎么握手、怎么调工具、怎么结束&quot;写死成固定流程，MCP Host只需照表填空，就可以实现LLM获取MCP Server提供的上下文。</p><p><strong>MCP Server 和 MCP Client 之间的通信&quot;两通道&quot;</strong><img src="`+p+'" alt="img_19.png"> 服务器启动时必须同时暴露这两个端点，缺一不可。</p><p><strong>MCP Server 和 MCP Client 之间的通信&quot;四步骤&quot;</strong></p><ol><li>连：客户端 发送<code>GET/sse</code>请求，建立sse长连接 ，用于后续服务端推送数据给客户端 ；</li><li>取：服务器回<code>event: endpoint</code>的消息，给出后续客户端发送信息给服务端的POST端点URI；</li><li>握：客户端向该 URI 发两包 JSON-RPC； <ul><li><code>initialize</code>请求 → 服务器返回<code>capabilities</code>；</li><li><code>notifications/initialized</code>通知 → 握手完成；</li></ul></li><li>用：正常会话； <ul><li><code>tools/list</code>（可选）拉可用工具；</li><li><code>tools/call</code>调用具体工具；</li><li>服务器随时在 SSE 流里推送状态更新 ；</li></ul></li><li>断：任一端关闭 SSE，会话结束。</li></ol><p><img src="'+o+'" alt="img_20.png"></p>',57)]))}const d=s(l,[["render",i]]),u=JSON.parse('{"path":"/blogs/AI/MCP.html","title":"AI Agent - MCP 了解","lang":"en-US","frontmatter":{"title":"AI Agent - MCP 了解","date":"2025/10/05","tags":["AI","AI Agent","MCP"],"categories":["AI Agent 学习日志"]},"headers":[{"level":2,"title":"MCP","slug":"mcp","link":"#mcp","children":[{"level":3,"title":"MCP解决的核心问题","slug":"mcp解决的核心问题","link":"#mcp解决的核心问题","children":[]},{"level":3,"title":"MCP技术原理深度解析","slug":"mcp技术原理深度解析","link":"#mcp技术原理深度解析","children":[]}]}],"git":{"createdTime":1755092504000,"updatedTime":1755092504000,"contributors":[{"name":"zxy","email":"zxy0613zxy@outlook.com","commits":1}]},"filePathRelative":"blogs/AI/MCP.md"}');export{d as comp,u as data};
