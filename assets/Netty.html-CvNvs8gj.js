import{_ as t,c as l,a as o,b as e,d as a,e as c,r as p,o as i}from"./app-ByLG9LQz.js";const d="/assets/1-Dl12_UJA.png",r="/assets/2-DxVkp9wM.png",u="/assets/3--d3vDEkQ.png",h="/assets/4-DR4CbuST.png",v="/assets/6-CplFGwO5.png",k="/assets/7-Bys_7F_n.png",b={},m={href:"https://javaguide.cn/java/io/io-model.html#nio-non-blocking-new-i-o",target:"_blank",rel:"noopener noreferrer"};function y(g,n){const s=p("ExternalLinkIcon");return i(),l("div",null,[n[2]||(n[2]=o('<p>Netty基于NIO，使用Netty可以极大地简化TCP和UDP套接字服务器等网络编程，提供高性能、可扩展的网络应用解决方案，并且性能以及安全性等方面都比较优秀。 我们平常接触到的Dubbo、RocketMQ、Elasticsearch、gRPC、Spark等热门开源项目都用到了Netty。 大部分微服务框架底层涉及到网络通信的部分都是基于Netty来做的，比如Spring Cloud生态系统中的网关Spring Cloud Gateway。</p><h2 id="nio、bio和aio的区别" tabindex="-1"><a class="header-anchor" href="#nio、bio和aio的区别"><span>NIO、BIO和AIO的区别</span></a></h2><p><img src="'+d+'" alt=""></p><h3 id="bio" tabindex="-1"><a class="header-anchor" href="#bio"><span>BIO</span></a></h3><p>BIO属于<strong>同步阻塞</strong>模型，数据的读取写入必须阻塞在一个线程内等待其完成。 <img src="'+r+'" alt=""> 在客户端连接数量不高的情况下，是没问题的。但当面对十万甚至百万级连接时，需要一种更高效得I/O处理模型来应对更高的并发量。</p><h3 id="nio" tabindex="-1"><a class="header-anchor" href="#nio"><span>NIO</span></a></h3><p><strong>同步非阻塞模型</strong><img src="'+u+'" alt=""> 同步非阻塞模型中，应用程序会已知发起<code>read</code>调用，等待数据准备就绪，再从内核空间拷贝到用户空间（这段时间线程仍然是阻塞的）。 同步非阻塞IO模型通过轮询操作，避免了一直阻塞。但同样存在问题：应用程序不断进行I/O系统调用轮询数据是否已经准备好的过程是非常消耗CPU资源的。</p><p><strong>I/O多路复用模型</strong><img src="'+h+'" alt=""> 线程首先发起<code>select</code>调用，询问内核数据是否准备就绪，等内核准备好数据了，用户线程再发起<code>read</code>调用（该过程仍然是阻塞的）。 I/O多路复用模型通过减少无效的系统调用，减少对CPU资源的消耗。I/O多路复用有一个重要的选择器概念，被称为多路复用器。 通过它，只需要一个线程就可以管理多个客户端连接</p><h3 id="aio" tabindex="-1"><a class="header-anchor" href="#aio"><span>AIO</span></a></h3><p>异步IO是基于事件和回调机制实现的，即应用操作之后会直接返回，不会阻塞在那。等后台处理完毕，操作系统会通知相应的线程进行后续的操作。</p><h2 id="netty是什么-为什么要用netty-不直接用nio呢" tabindex="-1"><a class="header-anchor" href="#netty是什么-为什么要用netty-不直接用nio呢"><span>Netty是什么，为什么要用Netty，不直接用NIO呢？</span></a></h2><ul><li>Netty是一个基于NIO的客户端服务器框架，使用它可以快速简单的开发网络应用程序</li><li>它极大的简化并优化了TCP和UDP套接字服务器等网络编程，并且性能和安全性等很多方面甚至都要更好。</li><li>支持多种协议，如FTP、SMTP、HTTP以及各种二进制和基于文本的传统协议。 总的来说：Netty成功找到了一种在不妥协性能和可维护性的情况下实现易于开发、性能、稳定性和灵活性的方法。</li></ul><p>NIO的编程模型复杂并且存在一些BUG对编程的功底要求较高，而且NIO在面对断连重连、包丢失、粘包等问题时处理过程非常复杂，Netty的出现正是为了解决这些问题。</p><p>Netty的优点：</p><ul><li>统一的API，支持阻塞和非阻塞</li><li>简单而强大的线程模型</li><li>自带编码器解决TCP粘包/拆包问题</li><li>自带各种协议栈</li><li>真正的无连接数据包套接字支持</li><li>比直接用Java核心API有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制</li><li>安全性不错，有完整的SSL/TLS以及StartTLS支持。</li><li>社区活跃</li><li>成熟稳定，经历了大型项目的使用和考验，很多开源项目都使用到了Netty。</li></ul><h2 id="netty的应用场景" tabindex="-1"><a class="header-anchor" href="#netty的应用场景"><span>Netty的应用场景</span></a></h2><p>理论上，NIO可以做的事情，Netty都可以做并且可以做的更好。Netty主要用来做网络通信</p><ul><li>作为RPC框架的网络通信工具：在分布式系统中，需要RPC框架来完成不同服务节点之间的相互调用。Netty可以实现不同服务节点的通信。</li><li>实现一个自己的HTTP服务器：通过Netty可以实现一个简单的HTTP服务器</li><li>实现一个即时通讯系统</li><li>实现消息推送</li></ul><h2 id="netty的核心组件及作用" tabindex="-1"><a class="header-anchor" href="#netty的核心组件及作用"><span>Netty的核心组件及作用</span></a></h2><p><img src="'+v+'" alt=""></p><h3 id="bytebuf-字节容器" tabindex="-1"><a class="header-anchor" href="#bytebuf-字节容器"><span>ByteBuf(字节容器)</span></a></h3><p>网络通信是通过字节流进行传输的。<code>ByteBuf</code>就是Netty提供的一个字节容器，内部是一个字节数组，Netty传输数据时，也是通过该组件进行。 我们可以将<code>ByteBuf</code>看作Netty对Java NIO提供了<code>ByteBuffer</code>字节容器的封装和抽象。</p><h3 id="bootstrap和serverbootstrap-启动引导类" tabindex="-1"><a class="header-anchor" href="#bootstrap和serverbootstrap-启动引导类"><span>Bootstrap和ServerBootstrap(启动引导类)</span></a></h3><p><code>Bootstrap</code>是客户端的启动引导类/辅助类，<code>ServerBootstrap</code>是服务端的启动引导类/辅助类</p><ul><li><code>Bootstrap</code>通常使用<code>connect()</code>方法连接到远程的主机和端口，作为一个Netty TCP协议通信中的客户端。还可以通过<code>bind()</code>方法绑定本地的一个端口，作为UDP协议通信的一段。</li><li><code>ServerBootstrap</code>通常使用<code>bind()</code>绑定在本地端口，等待客户端的连接。</li><li><code>Bootstrap</code>只需要配置一个线程组-<code>EventLoopGroup</code>，而<code>ServerBootstrap</code>需要配置两个线程组-<code>EventLoopGroup</code>，一个用于接收连接，一个用于具体的IO处理。</li></ul><h3 id="channel-网络操作抽象类" tabindex="-1"><a class="header-anchor" href="#channel-网络操作抽象类"><span>Channel(网络操作抽象类)</span></a></h3><p><code>Channel</code>接口是Netty对网络操作抽象类，通过<code>Channel</code>我们可以进行I/O操作。比较常用的<code>Channel</code>接口实现类有<code>NioServerSocketChannel</code>(服务端)和<code>NioSocketChannel</code>(客户端)。</p><h3 id="eventloop-事件循环" tabindex="-1"><a class="header-anchor" href="#eventloop-事件循环"><span>EventLoop(事件循环)</span></a></h3><p>主要作用就是责监听网络事件并调用事件处理器进行相关I/O操作（读写）的处理。</p><p><code>Channel</code>为Netty网络操作（读写等操作）抽象类，<code>EventLoop</code>负责处理注册到其上的<code>Channel</code>的I/O操作，两者配合进行I/O操作.</p><p><code>EventLoopGroup</code>包含多个<code>EventLoop</code>（每一个EventLoop通常内部包含一个线程），它管理所有的<code>EventLoop</code>的生命周期。<code>EventLoop</code>处理的I/O事件都将在它专有的<code>Thread</code>上被处理，即<code>Thread</code>和<code>EventLoop</code>属于1:1的关系，从而保证线程安全。</p><p><img src="'+k+`" alt=""></p><h3 id="channelhandler-消息处理器-和channelpipeline-channelhandler对象链表" tabindex="-1"><a class="header-anchor" href="#channelhandler-消息处理器-和channelpipeline-channelhandler对象链表"><span>ChannelHandler(消息处理器)和ChannelPipeline(ChannelHandler对象链表)</span></a></h3><p><code>ChannelHandler</code>是消息的具体处理器，主要负责处理客户端/服务端接收和发送的数据。 当<code>Channel</code>被创建时，它会被自动分配到它专属的<code>ChannelPipeline</code>。一个<code>Channel</code>包含一个<code>ChannelPipeline</code>。<code>ChannelPipeline</code>为<code>ChannelHandler</code>的链，一个<code>pipeline</code>上可以有多个<code>ChannelHandler</code>。</p><h3 id="channelfuture-操作执行结果" tabindex="-1"><a class="header-anchor" href="#channelfuture-操作执行结果"><span>ChannelFuture(操作执行结果)</span></a></h3><p>Netty中所有的I/O操作都是异步的，因此不能立刻得到操作是否执行成功。可以通过<code>ChannelFuture</code>接口的<code>addListener()</code>方法注册一个<code>ChannelFutureListener</code>，当操作执行成功或者失败，监听就会自动触发返回结果。 <code>channel()</code>方法获取连接相关联的<code>Channel</code>。<code>sync()</code>方法让异步操作变成同步的。</p><h2 id="nioeventloopgroup默认的构造函数会起多少线程" tabindex="-1"><a class="header-anchor" href="#nioeventloopgroup默认的构造函数会起多少线程"><span>NioEventLoopGroup默认的构造函数会起多少线程?</span></a></h2><p><strong>CPU核心数*2</strong></p><h2 id="reactor线程模型" tabindex="-1"><a class="header-anchor" href="#reactor线程模型"><span>Reactor线程模型</span></a></h2><p>Reactor是一种经典的线程模型，基于事件驱动，采用多路复用将事件分发给相应的<code>Handler</code>处理，适合处理海量的I/O事件。</p><h3 id="单线程reactor" tabindex="-1"><a class="header-anchor" href="#单线程reactor"><span>单线程Reactor</span></a></h3><p>所有的IO操作都由同一个NIO线程处理。</p><p>系统资源消耗小，不支持大量请求的应用场景并且处理请求的时间比较慢。</p><h3 id="多线程reactor" tabindex="-1"><a class="header-anchor" href="#多线程reactor"><span>多线程Reactor</span></a></h3><p>一个线程负责接受请求，一组NIO线程负责处理IO操作。</p><p>在并发连接数比较多的场景下会存在性能问题。</p><h3 id="主从多线程reactor" tabindex="-1"><a class="header-anchor" href="#主从多线程reactor"><span>主从多线程Reactor</span></a></h3><p>一组NIO线程负责接收请求，一组NIO线程负责处理IO操作。</p><h2 id="netty线程模型" tabindex="-1"><a class="header-anchor" href="#netty线程模型"><span>Netty线程模型</span></a></h2><p>大部分网络框架都基于Reactor模式设计开发。Netty主要靠<code>NioEventLoopGroup</code>线程池来实现线程模型。 在实现服务端时，一般会初始化两个数组</p><ul><li><code>bossGroup</code>：接收连接</li><li><code>workerGroup</code>：负责具体的处理，交由对应的Handler处理</li></ul><h3 id="单线程模型" tabindex="-1"><a class="header-anchor" href="#单线程模型"><span>单线程模型</span></a></h3><p>一个线程单独处理客户端连接以及I/O读写，涉及到<code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code>等事件。不适用高并发、高负载和性能要求较高的场景。</p><h3 id="多线程模型" tabindex="-1"><a class="header-anchor" href="#多线程模型"><span>多线程模型</span></a></h3><p>一个Acceptor线程只负责监听客户端的连接，一个NIO线程池负责处理I/O读写。 在并发连接大的时候会出现性能瓶颈。</p><h3 id="主从线程模型" tabindex="-1"><a class="header-anchor" href="#主从线程模型"><span>主从线程模型</span></a></h3><p>从一个主线程NIO线程池中选择一个线程作为Acceptor线程，绑定监听端口，接收客户端连接，其他线程负责后续的接入认证工作，建立完连接后，Sub NIO线程池负责具体处理I/O读写。</p><h2 id="netty服务端和客户端的启动流程" tabindex="-1"><a class="header-anchor" href="#netty服务端和客户端的启动流程"><span>Netty服务端和客户端的启动流程</span></a></h2><h3 id="服务端" tabindex="-1"><a class="header-anchor" href="#服务端"><span>服务端</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 1.md.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span>
<span class="line"><span class="token class-name">EventLoopGroup</span> bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1.</span>md<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">EventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span>
<span class="line"><span class="token class-name">ServerBootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//3.给引导类配置两大线程组,确定了线程模型</span></span>
<span class="line">b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// (非必备)打印日志</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span><span class="token constant">INFO</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// 4.指定 IO 模型</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token annotation punctuation">@Override</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token class-name">ChannelPipeline</span> p <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//5.可以自定义客户端消息的业务处理逻辑</span></span>
<span class="line">p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HelloServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 6.绑定端口,调用 sync 方法阻塞知道绑定完成</span></span>
<span class="line"><span class="token class-name">ChannelFuture</span> f <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法)</span></span>
<span class="line">f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token comment">//8.优雅关闭相关线程组资源</span></span>
<span class="line">bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>创建两个<code>NioEventLoopGroup</code>对象实例： <ul><li><code>bossGroup</code>：处理客户端的TCP连接请求</li><li><code>workerGroup</code>：负责每一条连接的具体读写数据的处理逻辑，真正负责I/O读写操作，交由对应的Handler处理。</li></ul></li><li>创建一个服务端启动引导/辅助类，引导进行服务端的启动工作。</li><li>通过<code>group()</code>方法给引导类<code>ServerBootstrap</code>配置两大线程组，确定了线程模型。</li><li>通过<code>channel()</code>方法给引导类<code>ServetBootstrap</code>指定了IO模型为NIO <ul><li><code>NioServerSocketChannel</code>：指定服务端的IO模型为NIO，与BIO编程模型中的ServerSocket对应</li><li><code>NioSocketChannel</code>：指定客户端的IO模型为NIO，与BIO编程模型中的Socket对应。</li></ul></li><li>通过<code>childHandler()</code>方法给引导类创建一个<code>ChannelInitializer</code>，然后指定服务端消息的业务处理逻辑<code>HelloServerHandler</code>对象。</li><li>调用<code>ServerBootstrap</code>类的<code>bind()</code>方法绑定端口。</li></ol><h3 id="客户端" tabindex="-1"><a class="header-anchor" href="#客户端"><span>客户端</span></a></h3><div class="language-Java line-numbers-mode" data-highlighter="prismjs" data-ext="Java" data-title="Java"><pre><code><span class="line">    //1.md.创建一个 NioEventLoopGroup 对象实例</span>
<span class="line">    EventLoopGroup group = new NioEventLoopGroup();</span>
<span class="line">    try {</span>
<span class="line">        //2.创建客户端启动引导/辅助类：Bootstrap</span>
<span class="line">        Bootstrap b = new Bootstrap();</span>
<span class="line">        //3.指定线程组</span>
<span class="line">        b.group(group)</span>
<span class="line">                //4.指定 IO 模型</span>
<span class="line">                .channel(NioSocketChannel.class)</span>
<span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {</span>
<span class="line">                    @Override</span>
<span class="line">                    public void initChannel(SocketChannel ch) throws Exception {</span>
<span class="line">                        ChannelPipeline p = ch.pipeline();</span>
<span class="line">                        // 5.这里可以自定义消息的业务处理逻辑</span>
<span class="line">                        p.addLast(new HelloClientHandler(message));</span>
<span class="line">                    }</span>
<span class="line">                });</span>
<span class="line">        // 6.尝试建立连接</span>
<span class="line">        ChannelFuture f = b.connect(host, port).sync();</span>
<span class="line">        // 7.等待连接关闭（阻塞，直到Channel关闭）</span>
<span class="line">        f.channel().closeFuture().sync();</span>
<span class="line">    } finally {</span>
<span class="line">        group.shutdownGracefully();</span>
<span class="line">    }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="6"><li>调用<code>Bootstrap</code>类的<code>connect()</code>方法进行连接，需要指定两个参数：<code>inetHost</code>：ip地址，<code>inetPort</code>：端口号</li></ol><h2 id="什么是tcp粘包-拆包-有什么解决方法" tabindex="-1"><a class="header-anchor" href="#什么是tcp粘包-拆包-有什么解决方法"><span>什么是TCP粘包/拆包？有什么解决方法</span></a></h2><p><strong>粘包</strong>：多个独立的应用层消息被合并成一个 TCP 数据包传输，接收端无法直接区分原始消息边界。 <strong>拆包</strong>：一个应用层消息被分割成多个 TCP 数据包传输，接收端需要将多个包重组为完整消息。</p><p>解决方法：</p><p>1.<strong>使用Netty自带的解码器</strong></p><ul><li><code>LineBasedFrameDecoder</code>：依次遍历<code>ByteBuf</code>中的可读字节，判断是否有换行符，然后进行截取。</li><li><code>DelimiterBasedFrameDecoder</code>：可以自定义分隔符解码器。</li><li><code>FixedLengthFrameDecoder</code>：固定长度解码器，按照指定的长度进行拆包，长度不够，则空格补全。</li><li><code>LengthFieldBasedFrameDecoder</code>：长度域解码器，根据发送的数据中消息长度相关参数（长度域偏移量）来进行拆包。 2.<strong>自定义序列化偏移量</strong></li></ul><p>Java自带有实现<code>Serializable</code>接口来实现序列化，不过由于性能、安全性等原因一般不用。</p><p><code>Protostuff</code>、<code>Hessian2</code>、<code>json</code>序列方式比较多，还有专门针对Java的<code>Kryo</code>、<code>FST</code>等，跨语言的<code>Protostuff</code>，<code>ProtoBuf</code>等。</p><h2 id="netty长连接、心跳机制" tabindex="-1"><a class="header-anchor" href="#netty长连接、心跳机制"><span>Netty长连接、心跳机制</span></a></h2><h3 id="tcp长连接、短连接" tabindex="-1"><a class="header-anchor" href="#tcp长连接、短连接"><span>TCP长连接、短连接</span></a></h3><p>短连接：服务端与客户端建立连接后，读写完成后就关闭连接，如果要再次发送消息，就要重新连接。 长连接：客户端向服务端建立连接后，不会主动关闭，后续的读写操作还是会继续使用这个连接。</p><h3 id="为什么需要心跳机制-netty的心跳机制" tabindex="-1"><a class="header-anchor" href="#为什么需要心跳机制-netty的心跳机制"><span>为什么需要心跳机制？Netty的心跳机制</span></a></h3><p>在TCP保持长连接的过程中，可能会出现断网等异常情况，当异常发生时，客户端和服务端之间如果没有交互，无法发现对方已经掉线，因此为了解决这个问题，就需要引入心跳机制。</p><p>心跳机制的工作原理：在客户端和服务端之间在一定时间内没有数据交互时，客户端或服务端就会发送一个特殊的服务包给对方，当接收方收到这个数据报文时，也会发送一个特殊的数据报文，回应发送方，这就是一个PING-PONG交互。</p><p>TCP自带的长连接选项本身就有心跳机制：<code>SO_KEEPLIVE</code>，但不够灵活。因此一般都是在应用层协议上实现自定义心跳机制。通过Netty实现心跳机制的核心类是：<code>IdleStateHandler</code>。</p>`,78)),e("p",null,[n[1]||(n[1]=a("参考文章： ")),e("a",m,[n[0]||(n[0]=a("Java IO 模型详解")),c(s)])])])}const f=t(b,[["render",y]]),C=JSON.parse('{"path":"/blogs/backend/Netty/Netty.html","title":"Netty学习总结","lang":"en-US","frontmatter":{"title":"Netty学习总结","date":"2025/04/24","tags":["框架","Netty"],"categories":["后端学习"]},"headers":[{"level":2,"title":"NIO、BIO和AIO的区别","slug":"nio、bio和aio的区别","link":"#nio、bio和aio的区别","children":[{"level":3,"title":"BIO","slug":"bio","link":"#bio","children":[]},{"level":3,"title":"NIO","slug":"nio","link":"#nio","children":[]},{"level":3,"title":"AIO","slug":"aio","link":"#aio","children":[]}]},{"level":2,"title":"Netty是什么，为什么要用Netty，不直接用NIO呢？","slug":"netty是什么-为什么要用netty-不直接用nio呢","link":"#netty是什么-为什么要用netty-不直接用nio呢","children":[]},{"level":2,"title":"Netty的应用场景","slug":"netty的应用场景","link":"#netty的应用场景","children":[]},{"level":2,"title":"Netty的核心组件及作用","slug":"netty的核心组件及作用","link":"#netty的核心组件及作用","children":[{"level":3,"title":"ByteBuf(字节容器)","slug":"bytebuf-字节容器","link":"#bytebuf-字节容器","children":[]},{"level":3,"title":"Bootstrap和ServerBootstrap(启动引导类)","slug":"bootstrap和serverbootstrap-启动引导类","link":"#bootstrap和serverbootstrap-启动引导类","children":[]},{"level":3,"title":"Channel(网络操作抽象类)","slug":"channel-网络操作抽象类","link":"#channel-网络操作抽象类","children":[]},{"level":3,"title":"EventLoop(事件循环)","slug":"eventloop-事件循环","link":"#eventloop-事件循环","children":[]},{"level":3,"title":"ChannelHandler(消息处理器)和ChannelPipeline(ChannelHandler对象链表)","slug":"channelhandler-消息处理器-和channelpipeline-channelhandler对象链表","link":"#channelhandler-消息处理器-和channelpipeline-channelhandler对象链表","children":[]},{"level":3,"title":"ChannelFuture(操作执行结果)","slug":"channelfuture-操作执行结果","link":"#channelfuture-操作执行结果","children":[]}]},{"level":2,"title":"NioEventLoopGroup默认的构造函数会起多少线程?","slug":"nioeventloopgroup默认的构造函数会起多少线程","link":"#nioeventloopgroup默认的构造函数会起多少线程","children":[]},{"level":2,"title":"Reactor线程模型","slug":"reactor线程模型","link":"#reactor线程模型","children":[{"level":3,"title":"单线程Reactor","slug":"单线程reactor","link":"#单线程reactor","children":[]},{"level":3,"title":"多线程Reactor","slug":"多线程reactor","link":"#多线程reactor","children":[]},{"level":3,"title":"主从多线程Reactor","slug":"主从多线程reactor","link":"#主从多线程reactor","children":[]}]},{"level":2,"title":"Netty线程模型","slug":"netty线程模型","link":"#netty线程模型","children":[{"level":3,"title":"单线程模型","slug":"单线程模型","link":"#单线程模型","children":[]},{"level":3,"title":"多线程模型","slug":"多线程模型","link":"#多线程模型","children":[]},{"level":3,"title":"主从线程模型","slug":"主从线程模型","link":"#主从线程模型","children":[]}]},{"level":2,"title":"Netty服务端和客户端的启动流程","slug":"netty服务端和客户端的启动流程","link":"#netty服务端和客户端的启动流程","children":[{"level":3,"title":"服务端","slug":"服务端","link":"#服务端","children":[]},{"level":3,"title":"客户端","slug":"客户端","link":"#客户端","children":[]}]},{"level":2,"title":"什么是TCP粘包/拆包？有什么解决方法","slug":"什么是tcp粘包-拆包-有什么解决方法","link":"#什么是tcp粘包-拆包-有什么解决方法","children":[]},{"level":2,"title":"Netty长连接、心跳机制","slug":"netty长连接、心跳机制","link":"#netty长连接、心跳机制","children":[{"level":3,"title":"TCP长连接、短连接","slug":"tcp长连接、短连接","link":"#tcp长连接、短连接","children":[]},{"level":3,"title":"为什么需要心跳机制？Netty的心跳机制","slug":"为什么需要心跳机制-netty的心跳机制","link":"#为什么需要心跳机制-netty的心跳机制","children":[]}]}],"git":{"createdTime":1749738693000,"updatedTime":1754659489000,"contributors":[{"name":"zxy","email":"zxy0613zxy@outlook.com","commits":3},{"name":"zxy","email":"431559981@qq.com","commits":1}]},"filePathRelative":"blogs/backend/Netty/Netty.md"}');export{f as comp,C as data};
