import{_ as i,c as e,a as d,o as a}from"./app-ByLG9LQz.js";const n={};function o(t,l){return a(),e("div",null,l[0]||(l[0]=[d('<p>MVCC（多版本并发控制）是一种并发机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。 当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p><p>MVCC的实现依赖于：Read View、undo log、隐藏字段。</p><h3 id="隐藏字段" tabindex="-1"><a class="header-anchor" href="#隐藏字段"><span>隐藏字段</span></a></h3><ul><li>DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务id。delete操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除。</li><li>DB_ROLL_PTR（7字节）：回滚指针，指向该行的 undo log 。如果该行未被更新，则为空。</li><li>DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引。</li></ul><h3 id="read-view" tabindex="-1"><a class="header-anchor" href="#read-view"><span>Read View</span></a></h3><p>Read View 主要是用来做可见性判断，里面保存了“当前对本事务不可见的其他活跃事务”，主要有以下字段</p><ul><li>m_low_limit_id：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li><li>m_up_limit_id：活跃事务列表 m_ids 中最小的事务 ID，如果 m_ids 为空，则 m_up_limit_id 为 m_low_limit_id。小于这个 ID 的数据版本均可见</li><li>m_ids：Read View 创建时其他未提交的活跃事务 ID 列表。创建 Read View时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。m_ids 不包括当前事务自己和已提交的事务（正在内存中）</li><li>m_creator_trx_id：创建该 Read View 的事务 ID</li></ul><h3 id="undo-log" tabindex="-1"><a class="header-anchor" href="#undo-log"><span>undo-log</span></a></h3><ul><li>当事务回滚时用于将数据恢复到修改的样子</li><li>另一个作用是 MVCC，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读</li></ul><p>在 InnoDB 存储引擎中 undo log 分为两种：insert undo log 和 update undo log：</p><ul><li>insert undo log：指在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，对其他事务不可见，故该 undo log 可以在事务提交后直接删除。不需要进行 purge 操作</li><li>update undo log：update 或 delete 操作中产生的 undo log。该 undo log可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge线程 进行最后的删除</li></ul><h3 id="数据可见性算法" tabindex="-1"><a class="header-anchor" href="#数据可见性算法"><span>数据可见性算法</span></a></h3><p>在 InnoDB 存储引擎中，创建一个新事务后，执行每个 select 语句前，都会创建一个快照（Read View），快照中保存了系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。 当用户在这个事务中要读取某个记录行的时候，InnoDB 会将该记录行的 DB_TRX_ID 与 Read View 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件。</p><ol><li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</li><li>如果 DB_TRX_ID &gt;= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</li><li>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</li><li>如果 m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的） <ul><li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</li><li>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</li></ul></li><li>在该记录行的 DB_ROLL_PTR 指针所指向的 undo log 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</li></ol><h3 id="rc-和-rr-隔离级别下-mvcc-的差异" tabindex="-1"><a class="header-anchor" href="#rc-和-rr-隔离级别下-mvcc-的差异"><span>RC 和 RR 隔离级别下 MVCC 的差异</span></a></h3><p>在事务隔离级别 RC 和 RR （InnoDB 存储引擎的默认事务隔离级别）下，InnoDB 存储引擎使用 MVCC（非锁定一致性读），但它们生成 Read View 的时机却不同</p><ul><li>在 RC 隔离级别下的 每次 select 查询前都生成一个Read View (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 第一次 select 数据前生成一个Read View（m_ids 列表）</li></ul>',17)]))}const r=i(n,[["render",o]]),s=JSON.parse('{"path":"/blogs/backend/MVCC.html","title":"MVCC详解","lang":"en-US","frontmatter":{"title":"MVCC详解","date":"2025/8/11","tags":["MYSQL","隔离性"],"categories":["后端学习"]},"headers":[{"level":3,"title":"隐藏字段","slug":"隐藏字段","link":"#隐藏字段","children":[]},{"level":3,"title":"Read View","slug":"read-view","link":"#read-view","children":[]},{"level":3,"title":"undo-log","slug":"undo-log","link":"#undo-log","children":[]},{"level":3,"title":"数据可见性算法","slug":"数据可见性算法","link":"#数据可见性算法","children":[]},{"level":3,"title":"RC 和 RR 隔离级别下 MVCC 的差异","slug":"rc-和-rr-隔离级别下-mvcc-的差异","link":"#rc-和-rr-隔离级别下-mvcc-的差异","children":[]}],"git":{"createdTime":1755092504000,"updatedTime":1755092504000,"contributors":[{"name":"zxy","email":"zxy0613zxy@outlook.com","commits":1}]},"filePathRelative":"blogs/backend/MVCC.md"}');export{r as comp,s as data};
