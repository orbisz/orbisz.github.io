<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-rc.19">
    <script>
      (function() {
        const userMode = localStorage.getItem('vuepress-reco-color-scheme') || 'auto';
        const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

        if (userMode === 'dark' || (userMode === 'auto' && systemDarkMode)) {
          document.documentElement.classList.toggle('dark', true);
        }
      })();
    </script>
    <link rel="icon" href="/favicon1.ico"><title>数据结构:图 | orbisz-Blog</title><meta name="description" content="Carpe diem">
    <link rel="preload" href="/assets/style-BwPacOyM.css" as="style"><link rel="stylesheet" href="/assets/style-BwPacOyM.css">
    <link rel="modulepreload" href="/assets/app-ByLG9LQz.js"><link rel="modulepreload" href="/assets/graph.html-CMWK02fE.js">
    <link rel="prefetch" href="/assets/timeline.html-D8bL9X10.js" as="script"><link rel="prefetch" href="/assets/posts.html-BUKh4Xkh.js" as="script"><link rel="prefetch" href="/assets/friendship-link.html-B2BltZ8v.js" as="script"><link rel="prefetch" href="/assets/1.html-By_0A9C9.js" as="script"><link rel="prefetch" href="/assets/2.html-DNr8z5qN.js" as="script"><link rel="prefetch" href="/assets/3.html-BPcxeU9p.js" as="script"><link rel="prefetch" href="/assets/1.html-3PHRKLWU.js" as="script"><link rel="prefetch" href="/assets/1.html-DkVM-LuR.js" as="script"><link rel="prefetch" href="/assets/1.html-NS5LR8hY.js" as="script"><link rel="prefetch" href="/assets/1.html-C63klMuD.js" as="script"><link rel="prefetch" href="/assets/2.html-CPgYeXMJ.js" as="script"><link rel="prefetch" href="/assets/1.html-mMC7k61w.js" as="script"><link rel="prefetch" href="/assets/2.html-CJMtKSph.js" as="script"><link rel="prefetch" href="/assets/1.html-DBlSI2e4.js" as="script"><link rel="prefetch" href="/assets/1.html-DCSLntsV.js" as="script"><link rel="prefetch" href="/assets/1.html-DTLpyGl-.js" as="script"><link rel="prefetch" href="/assets/2.html-8A1WoTob.js" as="script"><link rel="prefetch" href="/assets/1.html-Bhsd_8Ma.js" as="script"><link rel="prefetch" href="/assets/1.html-BcEZH6QN.js" as="script"><link rel="prefetch" href="/assets/1.html-DUo9XIu7.js" as="script"><link rel="prefetch" href="/assets/1.html-aeCs_6R3.js" as="script"><link rel="prefetch" href="/assets/1.html-CLsRxVZA.js" as="script"><link rel="prefetch" href="/assets/1.html-CPflLrjL.js" as="script"><link rel="prefetch" href="/assets/1.html-BZQF61Kr.js" as="script"><link rel="prefetch" href="/assets/1.html-BuQ4vSn_.js" as="script"><link rel="prefetch" href="/assets/1.html-_RYSIzBN.js" as="script"><link rel="prefetch" href="/assets/1.html-vSegm2e1.js" as="script"><link rel="prefetch" href="/assets/1.html-C3gqmBSn.js" as="script"><link rel="prefetch" href="/assets/1.html-CsjAdv5i.js" as="script"><link rel="prefetch" href="/assets/1.html-ClKiFCJy.js" as="script"><link rel="prefetch" href="/assets/1.html-oL1sf9fB.js" as="script"><link rel="prefetch" href="/assets/1.html-BI_bNO4t.js" as="script"><link rel="prefetch" href="/assets/1.html-CqNXE2Q5.js" as="script"><link rel="prefetch" href="/assets/1.html-k1hb51ft.js" as="script"><link rel="prefetch" href="/assets/1.html-Y0qfODzV.js" as="script"><link rel="prefetch" href="/assets/1.html-CCOmfO_W.js" as="script"><link rel="prefetch" href="/assets/2.html-D9xEUk1-.js" as="script"><link rel="prefetch" href="/assets/1.html-BpKCwn5L.js" as="script"><link rel="prefetch" href="/assets/1.html-nkyid-Hd.js" as="script"><link rel="prefetch" href="/assets/1.html-Bmy6fa2j.js" as="script"><link rel="prefetch" href="/assets/1.html-COJM2PfY.js" as="script"><link rel="prefetch" href="/assets/1.html-C8ReidTp.js" as="script"><link rel="prefetch" href="/assets/2.html-TpnPJT_m.js" as="script"><link rel="prefetch" href="/assets/1.html-B3SgaIFv.js" as="script"><link rel="prefetch" href="/assets/1.html-CLI4rAg1.js" as="script"><link rel="prefetch" href="/assets/1.html-2u3e_Su1.js" as="script"><link rel="prefetch" href="/assets/1.html-DPL_yd3D.js" as="script"><link rel="prefetch" href="/assets/2.html-DbERg0Rh.js" as="script"><link rel="prefetch" href="/assets/1.html-CATswM7G.js" as="script"><link rel="prefetch" href="/assets/1.html-BHKdEpx2.js" as="script"><link rel="prefetch" href="/assets/1.html-3kCVGkdp.js" as="script"><link rel="prefetch" href="/assets/1.html-C5G71N1C.js" as="script"><link rel="prefetch" href="/assets/1.html-WVycvXvq.js" as="script"><link rel="prefetch" href="/assets/1.html-Bmy6fa2j.js" as="script"><link rel="prefetch" href="/assets/1.html-BaRIUcjq.js" as="script"><link rel="prefetch" href="/assets/1.html-riVy44zH.js" as="script"><link rel="prefetch" href="/assets/1.html-DoIiqL-S.js" as="script"><link rel="prefetch" href="/assets/1.html-rulaLow8.js" as="script"><link rel="prefetch" href="/assets/1.html-BaRIUcjq.js" as="script"><link rel="prefetch" href="/assets/1.html-DmxGrvk8.js" as="script"><link rel="prefetch" href="/assets/1.html-C0l0Jkzg.js" as="script"><link rel="prefetch" href="/assets/1.html-GBpwaCie.js" as="script"><link rel="prefetch" href="/assets/1.html-_82cBIMV.js" as="script"><link rel="prefetch" href="/assets/1.html-CWfgrjaY.js" as="script"><link rel="prefetch" href="/assets/1.html-CtezQova.js" as="script"><link rel="prefetch" href="/assets/1.html-Dd5NbL6R.js" as="script"><link rel="prefetch" href="/assets/1.html-B0V40mYZ.js" as="script"><link rel="prefetch" href="/assets/1.html-Coqjh3BA.js" as="script"><link rel="prefetch" href="/assets/1.html-pZpEnwGj.js" as="script"><link rel="prefetch" href="/assets/1.html-DQjz_ldM.js" as="script"><link rel="prefetch" href="/assets/1.html-UzeOju-U.js" as="script"><link rel="prefetch" href="/assets/1.html-DU1MhTdD.js" as="script"><link rel="prefetch" href="/assets/1.html-CYmx0txs.js" as="script"><link rel="prefetch" href="/assets/2.html-BJBEBjEZ.js" as="script"><link rel="prefetch" href="/assets/3.html-C6CfWmfx.js" as="script"><link rel="prefetch" href="/assets/4.html-Ukw6i0YW.js" as="script"><link rel="prefetch" href="/assets/5.html-CAZt63lh.js" as="script"><link rel="prefetch" href="/assets/6.html-DK4tGfxS.js" as="script"><link rel="prefetch" href="/assets/index.html-BYz3YNfS.js" as="script"><link rel="prefetch" href="/assets/message-board.html-BcDI9Zkh.js" as="script"><link rel="prefetch" href="/assets/1.html-B29hZLBO.js" as="script"><link rel="prefetch" href="/assets/2.html-CrQNYLf5.js" as="script"><link rel="prefetch" href="/assets/AI_Coding.html-BtfP7Fop.js" as="script"><link rel="prefetch" href="/assets/claude.html-B4XkvgU5.js" as="script"><link rel="prefetch" href="/assets/MCP.html-C5AAcB-0.js" as="script"><link rel="prefetch" href="/assets/Memory.html-C3yktRTr.js" as="script"><link rel="prefetch" href="/assets/paper1.html-_YcSspz0.js" as="script"><link rel="prefetch" href="/assets/Prompt.html-CvIZrWLt.js" as="script"><link rel="prefetch" href="/assets/RAG.html-Dvt9_VvF.js" as="script"><link rel="prefetch" href="/assets/transformer.html-BZy-WUhL.js" as="script"><link rel="prefetch" href="/assets/DevelopmentTips.html-sPVXWJ6z.js" as="script"><link rel="prefetch" href="/assets/DI.html-BBUdts9f.js" as="script"><link rel="prefetch" href="/assets/MVCC.html-DPWGTGXx.js" as="script"><link rel="prefetch" href="/assets/mysql.html-B-1wD3tc.js" as="script"><link rel="prefetch" href="/assets/RDBandAOF.html-BrbE_LMN.js" as="script"><link rel="prefetch" href="/assets/SpringBootStarter.html-v-qKlnoz.js" as="script"><link rel="prefetch" href="/assets/xitongshejitu.html-Bof_9_b0.js" as="script"><link rel="prefetch" href="/assets/yuanma.html-BCQPodmS.js" as="script"><link rel="prefetch" href="/assets/1.html-Br9DSheP.js" as="script"><link rel="prefetch" href="/assets/1.html-CcP5DXmW.js" as="script"><link rel="prefetch" href="/assets/2.html-Cm4dgxaI.js" as="script"><link rel="prefetch" href="/assets/3.html-w8dg-vrR.js" as="script"><link rel="prefetch" href="/assets/5.html-Bcef1yeB.js" as="script"><link rel="prefetch" href="/assets/offer-java.html-DaXG1nfx.js" as="script"><link rel="prefetch" href="/assets/offer-java2.html-C6oKnrQY.js" as="script"><link rel="prefetch" href="/assets/offer-java3.html-tlhilY5a.js" as="script"><link rel="prefetch" href="/assets/paixu.html-BhIgkN9d.js" as="script"><link rel="prefetch" href="/assets/stackandheap.html-BAsHdm8E.js" as="script"><link rel="prefetch" href="/assets/tanxin.html-Bk3RTeJQ.js" as="script"><link rel="prefetch" href="/assets/union.html-BYK06_pi.js" as="script"><link rel="prefetch" href="/assets/2.html-BDRLyHub.js" as="script"><link rel="prefetch" href="/assets/OpenAI2025.html-C4v3A5bQ.js" as="script"><link rel="prefetch" href="/assets/DDD.html-DP-1YKBE.js" as="script"><link rel="prefetch" href="/assets/1.html-s1SVgBsH.js" as="script"><link rel="prefetch" href="/assets/docker.html-B3AxyQoO.js" as="script"><link rel="prefetch" href="/assets/mybatis.html-DsKD7sz4.js" as="script"><link rel="prefetch" href="/assets/1.html-4OfMoKIH.js" as="script"><link rel="prefetch" href="/assets/Netty.html-CvNvs8gj.js" as="script"><link rel="prefetch" href="/assets/code-review.html-0blJbOTz.js" as="script"><link rel="prefetch" href="/assets/1.html-C3we6iIC.js" as="script"><link rel="prefetch" href="/assets/IM.html-Dmny0O1g.js" as="script"><link rel="prefetch" href="/assets/mybatis.html-Ckxkw3mS.js" as="script"><link rel="prefetch" href="/assets/one-api-sdk.html-C554EwZe.js" as="script"><link rel="prefetch" href="/assets/dayingxiao.html-CvzF91LB.js" as="script"><link rel="prefetch" href="/assets/dayingxiao1.html-BkE9kCui.js" as="script"><link rel="prefetch" href="/assets/dayingxiao2.html-C7nq8KqK.js" as="script"><link rel="prefetch" href="/assets/dayingxiao3.html-BrwNtLNp.js" as="script"><link rel="prefetch" href="/assets/dayingxiao4.html-BFTeAFH7.js" as="script"><link rel="prefetch" href="/assets/guide.html-1rgatwtb.js" as="script"><link rel="prefetch" href="/assets/1.html-KhhNp96o.js" as="script"><link rel="prefetch" href="/assets/2.html-BdjVFHml.js" as="script"><link rel="prefetch" href="/assets/3.html-DL9V897o.js" as="script"><link rel="prefetch" href="/assets/4.html-BNXZBfjk.js" as="script"><link rel="prefetch" href="/assets/4.html-Cxyn_WRa.js" as="script"><link rel="prefetch" href="/assets/5.html-skRFr1UF.js" as="script"><link rel="prefetch" href="/assets/wrench1.html-B0D5O5uC.js" as="script"><link rel="prefetch" href="/assets/wrench2.html-BG3zwCYI.js" as="script"><link rel="prefetch" href="/assets/wrench3.html-CGUz_RsK.js" as="script"><link rel="prefetch" href="/assets/404.html-Dj_9d147.js" as="script"><link rel="prefetch" href="/assets/Valine.min-_LyT3bfY.js" as="script"><link rel="prefetch" href="/assets/giscus-aTimukGI-DWEKOTfS.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container series--no show-catalog"><header class="navbar-container not-open"><div class="navbar-inner"><div class="site-brand nav-item"><img class="logo" src="/logo1.jpg" alt="orbisz-Blog"><a href="/" class="site-name can-hide">orbisz-Blog</a></div><div class="nav-item navbar-links-wrapper" style=""><div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div><nav class="navbar-links"><!--[--><div class="navbar-links__item"><a href="/" class="link" aria-label="首页"><!--[--><!--]--><span class="xicon-container left"><!--[--><IconHome class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:;"></IconHome><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->首页<!--]--></span></span><!--[--><!--]--></a></div><div class="navbar-links__item"><a href="/docs/message-board" class="link" aria-label="留言板"><!--[--><!--]--><span class="xicon-container left"><!--[--><IconChat class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:;"></IconChat><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->留言板<!--]--></span></span><!--[--><!--]--></a></div><div class="navbar-links__item"><a class="link" href="https://blog.csdn.net/hywzxy" target="_blank" rel="noopener noreferrer" aria-label="CSDN"><!--[--><!--]--><span class="xicon-container left"><!--[--><IconCSDN class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:;"></IconCSDN><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->CSDN<!--]--></span></span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-links__item"><a class="link" href="https://github.com/orbisz" target="_blank" rel="noopener noreferrer" aria-label="Github"><!--[--><!--]--><span class="xicon-container left"><!--[--><IconGithub class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:;"></IconGithub><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->Github<!--]--></span></span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-links__item"><div class="dropdown-link"><button class="dropdown-link__title" type="button" aria-label="项目体验"><span class="xicon-container left title"><!--[--><!----><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->项目体验<!--]--></span></span><span class="arrow down"></span></button><button class="dropdown-link--mobile__title" type="button" aria-label="项目体验"><span class="title"><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->项目体验<!--]--></span></span></span><span class="right arrow"></span></button><ul style="display:none;" class="dropdown-link__container"><!--[--><li class="dropdown-link__item"><a class="link" href="http://117.72.164.204:3000/?userId=zxy&amp;activityId=100301" target="_blank" rel="noopener noreferrer" aria-label="幸运营销汇"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->幸运营销汇<!--]--></span></span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="dropdown-link__item"><a class="link" href="http://101.43.191.204" target="_blank" rel="noopener noreferrer" aria-label="Ai-Agent 智能体 "><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->Ai-Agent 智能体 <!--]--></span></span><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><!--]--></ul></div></div><!--]--><!----><span class="xicon-container btn-toggle-dark-mode btn--dark-mode navbar-links__item"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 32 32" style="width:20px;height:20px;font-size:20px;color:;"><path d="M15 2h2v3h-2z" fill="currentColor"></path><path d="M27 15h3v2h-3z" fill="currentColor"></path><path d="M15 27h2v3h-2z" fill="currentColor"></path><path d="M2 15h3v2H2z" fill="currentColor"></path><path d="M5.45 6.884l1.414-1.415l2.121 2.122l-1.414 1.414z" fill="currentColor"></path><path d="M23 7.58l2.121-2.12l1.414 1.414l-2.121 2.121z" fill="currentColor"></path><path d="M23.002 24.416l1.415-1.414l2.12 2.122l-1.413 1.414z" fill="currentColor"></path><path d="M5.47 25.13L7.59 23L9 24.42l-2.12 2.12l-1.41-1.41z" fill="currentColor"></path><path d="M16 8a8 8 0 1 0 8 8a8 8 0 0 0-8-8zm0 14a6 6 0 0 1 0-12z" fill="currentColor"></path></svg></span><ul class="social-links navbar-links__item"><!--[--><!--]--></ul></nav><span class="xicon-container btn-toggle-menus"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 32 32" style="width:20px;height:20px;font-size:20px;color:;"><circle cx="16" cy="8" r="2" fill="currentColor"></circle><circle cx="16" cy="16" r="2" fill="currentColor"></circle><circle cx="16" cy="24" r="2" fill="currentColor"></circle></svg></span></div></div></header><!----><!----><!----><div class="theme-main" style=""><!----><!--[--><main class="page-container"><div class="page-content"><h1 class="page-title">数据结构:图</h1><div class="page-info"><span class="xicon-container left"><!--[--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 32 32" class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:;"><path d="M16 4a5 5 0 1 1-5 5a5 5 0 0 1 5-5m0-2a7 7 0 1 0 7 7a7 7 0 0 0-7-7z" fill="currentColor"></path><path d="M26 30h-2v-5a5 5 0 0 0-5-5h-6a5 5 0 0 0-5 5v5H6v-5a7 7 0 0 1 7-7h6a7 7 0 0 1 7 7z" fill="currentColor"></path></svg><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->orbisz<!--]--></span></span><span class="xicon-container left"><!--[--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 32 32" class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:;"><path d="M26 4h-4V2h-2v2h-8V2h-2v2H6c-1.1 0-2 .9-2 2v20c0 1.1.9 2 2 2h20c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 22H6V12h20v14zm0-16H6V6h4v2h2V6h8v2h2V6h4v4z" fill="currentColor"></path></svg><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->2025/10/02<!--]--></span></span><span class="xicon-container left"><!--[--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 32 32" class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:;"><path d="M11.17 6l3.42 3.41l.58.59H28v16H4V6h7.17m0-2H4a2 2 0 0 0-2 2v20a2 2 0 0 0 2 2h24a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2H16l-3.41-3.41A2 2 0 0 0 11.17 4z" fill="currentColor"></path></svg><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[--><!--[--><a href="/categories/suanfa/1.html" class="">算法</a><!--]--><!--]--></span></span><span class="xicon-container left"><!--[--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 32 32" class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:;"><path d="M10 14a4 4 0 1 1 4-4a4.005 4.005 0 0 1-4 4zm0-6a2 2 0 1 0 1.998 2.004A2.002 2.002 0 0 0 10 8z" fill="currentColor"></path><path d="M16.644 29.415L2.586 15.354A2 2 0 0 1 2 13.941V4a2 2 0 0 1 2-2h9.941a2 2 0 0 1 1.414.586l14.06 14.058a2 2 0 0 1 0 2.828l-9.943 9.943a2 2 0 0 1-2.829 0zM4 4v9.942L18.058 28L28 18.058L13.942 4z" fill="currentColor"></path></svg><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[--><!--[--><a href="/tags/Java/1.html" class="">Java</a><!--]--><!--]--></span></span><span class="xicon-container left"><!--[--><svg class="xicon-icon" style="width:18px;height:18px;font-size:18px;color:;font-size:18px;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 12 12"><g fill="none"><path d="M1.974 6.659a.5.5 0 0 1-.948-.317c-.01.03 0-.001 0-.001a1.633 1.633 0 0 1 .062-.162c.04-.095.099-.226.18-.381c.165-.31.422-.723.801-1.136C2.834 3.827 4.087 3 6 3c1.913 0 3.166.827 3.931 1.662a5.479 5.479 0 0 1 .98 1.517l.046.113c.003.008.013.06.023.11L11 6.5s.084.333-.342.474a.5.5 0 0 1-.632-.314v-.003l-.006-.016a3.678 3.678 0 0 0-.172-.376a4.477 4.477 0 0 0-.654-.927C8.584 4.673 7.587 4 6 4s-2.584.673-3.194 1.338a4.477 4.477 0 0 0-.795 1.225a2.209 2.209 0 0 0-.03.078l-.007.018zM6 5a2 2 0 1 0 0 4a2 2 0 0 0 0-4zM5 7a1 1 0 1 1 2 0a1 1 0 0 1-2 0z" fill="currentColor"></path></g></svg><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[--><span id="/blogs/algorithm/graph.html" class="leancloud-visitors" data-flag-title="Your Article Title"><a class="leancloud-visitors-count" style=""></a></span><!----><!--]--></span></span></div><div class="theme-reco-md-content"><div><p>在图形结构中，节点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</p><h3 id="图的基本概念" tabindex="-1"><a class="header-anchor" href="#图的基本概念"><span>图的基本概念</span></a></h3><p>图（Graph）是由顶点的有穷非空集合 $V(G)$ 和顶点之间边的集合 $ E(G) $ 组成，通常表示为：$ G = (V, E) $， 其中，$ G $ 表示一个图，$ V $ 是图 $ G $ 中顶点的集合，$ E $ 是图 $ G $ 中边的集合。若 $ V = {v_1, v_2, \dots, v_n} $， 则用 $ |V| $ 表示图 $ G $ 中顶点的个数，也称图 $ G $ 的阶，$ E = {(u, v) | u \in V, v \in V} $，用 $ |E| $ 表示图 $ G $ 中边的条数。</p><blockquote><p>图一定不能是空图，即图的顶点集 $ V $ 一定非空，单边集 $ E $ 可以为空，此时图中只有顶点，没有边</p></blockquote><h3 id="图的基本概念-1" tabindex="-1"><a class="header-anchor" href="#图的基本概念-1"><span>图的基本概念</span></a></h3><h4 id="_1-有向图" tabindex="-1"><a class="header-anchor" href="#_1-有向图"><span>1. 有向图</span></a></h4><p>若 $ E $ 是有向边（也称弧）的有限集合时，则图 $ G $ 为有向图。弧是顶点的有序对，记为 $ \langle v, w \rangle $，其中 $ v $、$ w $ 是顶点，$ v $ 称为弧尾， $ w $ 称为弧头，$ \langle v, w \rangle $ 称为从顶点 $ v $ 到顶点 $ w $ 的弧，也称 $ v $ 邻接到 $ w $，或 $ w $ 邻接自 $ v $。</p><p><img src="/assets/img-Doy8sr3D.png" alt="img.png"></p><h4 id="_2-无向图" tabindex="-1"><a class="header-anchor" href="#_2-无向图"><span>2. 无向图</span></a></h4><p>若 $ E $ 是无向边（简称边）的有限集合时，则图 $ G $ 为无向图。边是顶点的无序对，记为 $ (v, w) $ 或 $ (w, v) $，因为 $ (v, w) = (w, v) $， 其中 $ v $、$ w $ 是顶点。可以说顶点 $ w $ 和顶点 $ v $ 互为邻接点。边 $ (v, w) $ 依附于顶点 $ w $ 和 $ v $，或者说边 $ (v, w) $ 和顶点 $ v $、$ w $ 相关联。</p><p><img src="/assets/img_1-C4M4vW4l.png" alt="img_1.png"></p><h4 id="_3-简单图" tabindex="-1"><a class="header-anchor" href="#_3-简单图"><span>3. 简单图</span></a></h4><p>简单图是图论中最基础的图类型，满足两个核心条件：</p><ul><li>无自环：不存在顶点到自身的边（即没有形如 $ u \leftrightarrow u $的边）；</li><li>无多重边：任意两个不同顶点之间最多有一条边（无向图中无重复的 $(u,v)$边；有向图中无重复的 $(u,v)$ 或 $(v,u)$ 方向的边）。</li></ul><h4 id="_4-多重图" tabindex="-1"><a class="header-anchor" href="#_4-多重图"><span>4.多重图</span></a></h4><p>多重图放宽了简单图的“无多重边”限制，允许两个顶点之间存在多条边（即边的多重性），但通常仍保留“无自环”或”允许自环“（因定义而异，常见定义不限制自环）。</p><h4 id="_5-简单完全图" tabindex="-1"><a class="header-anchor" href="#_5-简单完全图"><span>5. 简单完全图</span></a></h4><p>对于无向图，$|E|$ 的取值范围是 $0$ 到 $n(n - 1)/2$，有 $n(n - 1)/2$ 条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边。 对于有向图，$|E|$ 的取值范围是 $0$ 到 $n(n - 1)$，有 $n(n - 1)$ 条弧的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。 上图中 $G_2$ 为无向完全图，而 $G_3$ 为有向完全图。</p><p><img src="data:image/png;base64,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" alt="img_2.png"></p><h4 id="_6-子图" tabindex="-1"><a class="header-anchor" href="#_6-子图"><span>6. 子图</span></a></h4><p>设有两个图 $ G = (V, E) $ 和 $ G&#39; = (V&#39;, E&#39;) $，若 $ V&#39; $ 是 $ V $ 的子集，且 $ E&#39; $ 是 $ E $ 的子集，则称 $ G&#39; $ 是 $ G $ 的子图。 若有满足 $ V(G&#39;) = V(G) $ 的子图 $ G&#39; $，则称其为 $ G $ 的生成子图。上图中 $ G_3 $ 为 $ G_1 $ 的子图。</p><blockquote><p>注意：并非 $ V $ 和 $ E $ 的任何子集都能构成 $ G $ 的子图，因为这样的子集可能不是图，即 $ E $ 的子集中的某些边关联的顶点可能不在这个 $ V $ 的子集中。</p></blockquote><h4 id="_7、连通、连通图和连通分量" tabindex="-1"><a class="header-anchor" href="#_7、连通、连通图和连通分量"><span>7、连通、连通图和连通分量</span></a></h4><p>在无向图中，若从顶点 $ v $ 到顶点 $ w $ 有路径存在，则称 $ v $ 和 $ w $ 是连通的。若图 $ G $ 中任意两个顶点都是连通的，则称图 $ G $ 为<strong>连通图</strong>， 否则称为<strong>非连通图</strong>。无向图中的极大连通子图称为<strong>连通分量</strong>。若一个图有 $ n $ 个顶点，并且边数小于 $ n - 1 $，则此图必是非连通图。 如下图(a)所示，图 $ G_4 $ 有3个连通分量，如图 (b) 所示。</p><p><img src="/assets/img_3-BNOV-gsr.png" alt="img_3.png"></p><blockquote><p>极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边;极小连通子图是既要保持图连通又要使得边数最少的子图。</p></blockquote><h4 id="_8、强连通图、强连通分量" tabindex="-1"><a class="header-anchor" href="#_8、强连通图、强连通分量"><span>8、强连通图、强连通分量</span></a></h4><p>在有向图中，若从顶点 $ v $ 到顶点 $ w $ 和从顶点 $ w $ 到顶点 $ v $ 之间都有路径，则称这两个顶点是强连通的。 若图中任何一对顶点都是强连通的，则称此图为<strong>强连通图</strong>。有向图中的极大强连通子图称为有向图的<strong>强连通分量</strong>，图 $ G_1 $ 的强连通分量如下图所示。</p><p><img src="data:image/png;base64,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" alt="img_4.png"></p><blockquote><p>注意：强连通图、强连通分量只是针对有向图而言的。一般在无向图中讨论连通性，在有向图中考虑强连通性。</p></blockquote><h4 id="_9、生成树、生成森林" tabindex="-1"><a class="header-anchor" href="#_9、生成树、生成森林"><span>9、生成树、生成森林</span></a></h4><p>连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 $ n $，则它的生成树含有 $ n - 1 $ 条边。 对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的<strong>生成森林</strong>，即生成森林是非连通图的生成树集合。图 $ G_2 $ 的一个生成树如下图所示。</p><p><img src="/assets/img_5-Cjsd-Uh5.png" alt="img_5.png"></p><blockquote><p>注意：包含无向图中全部顶点的极小连通子图，只有生成树满足条件，因为砍去生成树的任一条边，图将不再连通。</p></blockquote><h4 id="_10、顶点的度、入度和出度" tabindex="-1"><a class="header-anchor" href="#_10、顶点的度、入度和出度"><span>10、顶点的度、入度和出度</span></a></h4><p>图中每个顶点的度定义为以该顶点为一个端点的边的数目。 对于无向图，顶点 $ v $ 的度是指依附于该顶点的边的条数，记为 $ TD(v) $。 在具有 $ n $ 个顶点、$ e $ 条边的无向图中，$\sum_{i=1}^{n} TD(v_i) = 2e$，即无向图的全部顶点的度的和等于边数的2倍，因为每条边和两个顶点相关联。 对于有向图，顶点 $ v $ 的度分为入度和出度，入度是以顶点 $ v $ 为终点的有向边的数目，记为 $ ID(v) $；而出度是以顶点 $ v $ 为起点的有向边的数目，记为 $ OD(v) $。 顶点 $ v $ 的度等于其入度和出度之和，即 $ TD(v) = ID(v) + OD(v) $。 在具有 $ n $ 个顶点、$ e $ 条边的有向图中，$\sum_{i=1}^{n} ID(v_i) = \sum_{i=1}^{n} OD(v_i) = e$，即有向图的全部顶点的入度之和与出度之和相等，并且等于边数。 这是因为每条有向边都有一个起点和终点。</p><h4 id="_11、边的权和网" tabindex="-1"><a class="header-anchor" href="#_11、边的权和网"><span>11、边的权和网</span></a></h4><p>在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的<strong>权值</strong>。这种边上带有权值的图称为<strong>带权图</strong>，也称<strong>网</strong>。</p><h4 id="_12、稠密图、稀疏图" tabindex="-1"><a class="header-anchor" href="#_12、稠密图、稀疏图"><span>12、稠密图、稀疏图</span></a></h4><p>边数很少的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong>。稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图 $ G $ 满足 $ |E| &lt; |V| \log|V| $ 时，可以将 $ G $ 视为稀疏图。</p><h4 id="_13、路径、路径长度和回路" tabindex="-1"><a class="header-anchor" href="#_13、路径、路径长度和回路"><span>13、路径、路径长度和回路</span></a></h4><p>顶点 $ v_p $ 到顶点 $ v_q $ 之间的一条路径是指顶点序列 $ v_p, v_{i_1}, v_{i_2}, \dots, v_{i_m}, v_q $，当然关联的边也可以理解为路径的构成要素。 路径上边的数目称为<strong>路径长度</strong>。第一个顶点和最后一个顶点相同的路径称为<strong>回路</strong>或<strong>环</strong>。若一个图有 $ n $ 个顶点，并且有大于 $ n - 1 $ 条边，则此图一定有环。</p><h4 id="_14、简单路径、简单回路" tabindex="-1"><a class="header-anchor" href="#_14、简单路径、简单回路"><span>14、简单路径、简单回路</span></a></h4><p>在路径序列中，顶点不重复出现的路径称为<strong>简单路径</strong>。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为<strong>简单回路</strong>。</p><h4 id="_15、距离" tabindex="-1"><a class="header-anchor" href="#_15、距离"><span>15、距离</span></a></h4><p>从顶点 $ u $ 出发到顶点 $ v $ 的最短路径若存在，则此路径的长度称为从 $ u $ 到 $ v $ 的<strong>距离</strong>。 若从 $ u $ 到 $ v $ 根本不存在路径，则记该距离为无穷（$ \infty $）。</p><h4 id="_16、有向树" tabindex="-1"><a class="header-anchor" href="#_16、有向树"><span>16、有向树</span></a></h4><p>一个顶点的入度为 $ 0 $、其余顶点的入度均为 $ 1 $ 的有向图，称为<strong>有向树</strong>。</p><h3 id="图的存储结构" tabindex="-1"><a class="header-anchor" href="#图的存储结构"><span>图的存储结构</span></a></h3><p>由于图的任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，即图不可能用简单的顺序存储结构来表示。 而多重链表的方式，要么会造成很多存储单元的浪费，要么又带来操作的不便。因此，对于图来说，如何对它实现物理存储是个难题。</p><h4 id="_1-邻接矩阵" tabindex="-1"><a class="header-anchor" href="#_1-邻接矩阵"><span>1. 邻接矩阵</span></a></h4><p>图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</p><p>设图 $ G $ 有 $ n $ 个顶点，则邻接矩阵 $ A $ 是一个 $ n \times n $ 的方阵，定义为： <img src="/assets/img_7-DIyWtmwi.png" alt="img_7.png"></p><p>下图是一个无向图和它的邻接矩阵： <img src="/assets/img_6-Dgr-4odZ.png" alt="img_6.png"></p><p>可以看出：</p><ol><li>无向图的邻接矩阵一定是一个<strong>对称矩阵</strong>（即从矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的）。因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。</li><li>对于无向图，邻接矩阵的第 $ i $ 行（或第 $ i $ 列）非零元素（或非 $ \infty $ 元素）的个数正好是第 $ i $ 个顶点的度 $ TD(v_i) $。比如顶点 $ v_1 $ 的度就是 $ 1 + 0 + 1 + 0 = 2 $。</li><li>求顶点 $ v_i $ 的所有邻接点就是将矩阵中第 $ i $ 行元素扫描一遍，$ A[i][j] $ 为 1 就是邻接点。</li></ol><p>下图是有向图和它的邻接矩阵： <img src="/assets/img_8-DJPeXaj3.png" alt="img_8.png"></p><p>可以看出：</p><ol><li>主对角线上数值依然为 0，但因为是有向图，所以此矩阵并不对称。</li><li>有向图讲究入度与出度，顶点 $ v_1 $ 的入度为 1，正好是第 $ v_1 $ 列各数之和。顶点 $ v_1 $ 的出度为 2，即第 $ v_1 $ 行的各数之和。</li><li>与无向图同样的办法，判断顶点 $ v_i $ 到 $ v_j $ 是否存在弧，只需要查找矩阵中 $ A[i][j] $ 是否为 1 即可。</li></ol><p>对于带权图而言,若顶点 $v_i$ 和 $v_j$之间有边相连，则邻接矩阵中对应项存放着该边对应的权值 <img src="/assets/img_9-Rq0vHQ-k.png" alt="img_9.png"></p><p>下图是有向网图和它的邻接矩阵： <img src="/assets/img_10-DmU5BEi3.png" alt="img_10.png"></p><h5 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * 邻接矩阵表示的图结构（对应C语言的MGraph）</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MGraph</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 顶点数最大值（对应C的MaxVertexNum宏）</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_VERTEX_NUM</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// 顶点表：存储顶点数据（原C的VertexType Vex[]，此处用char数组对应原char类型顶点）</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vertexArray<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 邻接矩阵：存储边的权值（原C的EdgeType Edge[][]，此处用int二维数组对应原int权值）</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> adjacencyMatrix<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 当前图的顶点数（对应原vexnum）</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> vertexCount<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 当前图的弧（边）数（对应原arcnum）</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> arcCount<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 默认构造方法：初始化空图</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">MGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>vertexArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token constant">MAX_VERTEX_NUM</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>adjacencyMatrix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token constant">MAX_VERTEX_NUM</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token constant">MAX_VERTEX_NUM</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>vertexCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>arcCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        </span>
<span class="line">        <span class="token comment">// 可选：初始化邻接矩阵为&quot;无连接&quot;状态（Java默认int为0，已满足）</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// ---------------------- 可选扩展方法（非原结构必需，但常用） ----------------------</span></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 添加顶点</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">vertex</span> 顶点数据（char类型，对应原VertexType）</span>
<span class="line">     * <span class="token keyword">@return</span> 是否添加成功（顶点数未超过最大值）</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addVertex</span><span class="token punctuation">(</span><span class="token keyword">char</span> vertex<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>vertexCount <span class="token operator">&gt;=</span> <span class="token constant">MAX_VERTEX_NUM</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">        vertexArray<span class="token punctuation">[</span>vertexCount<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> vertex<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 添加边（无向图）</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">v1</span> 顶点1的索引（从0开始）</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">v2</span> 顶点2的索引（从0开始）</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">weight</span> 边的权值（对应原EdgeType）</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> v1 <span class="token operator">&gt;=</span> vertexCount <span class="token operator">||</span> v2 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> v2 <span class="token operator">&gt;=</span> vertexCount<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 无向图：对称赋值</span></span>
<span class="line">        adjacencyMatrix<span class="token punctuation">[</span>v1<span class="token punctuation">]</span><span class="token punctuation">[</span>v2<span class="token punctuation">]</span> <span class="token operator">=</span> weight<span class="token punctuation">;</span></span>
<span class="line">        adjacencyMatrix<span class="token punctuation">[</span>v2<span class="token punctuation">]</span><span class="token punctuation">[</span>v1<span class="token punctuation">]</span> <span class="token operator">=</span> weight<span class="token punctuation">;</span></span>
<span class="line">        arcCount<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 无向图每条边算1条弧</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 添加边（有向图）</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">from</span> 源顶点索引</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">to</span> 目标顶点索引</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">weight</span> 边的权值</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addDirectedEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>from <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> from <span class="token operator">&gt;=</span> vertexCount <span class="token operator">||</span> <span class="token keyword">to</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token keyword">to</span> <span class="token operator">&gt;=</span> vertexCount<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">        adjacencyMatrix<span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">to</span><span class="token punctuation">]</span> <span class="token operator">=</span> weight<span class="token punctuation">;</span></span>
<span class="line">        arcCount<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 有向图每条边算1条弧</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>注意</strong></p><p>① 在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。</p><p>② 当邻接矩阵中的元素仅表示相应的边是否存在时，<code>EdgeType</code> 可定义为值为和 1 的枚举类型。</p><p>③ 无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。</p><p>④ 邻接矩阵表示法的空间复杂度为 $ O(n^2) $，其中 $ n $ 为图的顶点数 $ |V| $。</p><p>⑤ 用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</p><p>⑥ 稠密图适合使用邻接矩阵的存储表示。</p></blockquote><h4 id="_2-邻接图" tabindex="-1"><a class="header-anchor" href="#_2-邻接图"><span>2. 邻接图</span></a></h4><p>当一个图为稀疏图时，可以使用邻接矩阵会浪费大量存储空间，而邻接表结合了顺序存储和链式存储，大大减少了不必要的空间浪费。</p><p>所谓邻接表，是指对图 $ G $ 中的每个顶点 $ v_i $ 建立一个单链表，第 $ i $ 个单链表中的结点表示依附于顶点 $ v_i $ 的边（对于有向图则是以顶点 $ v_i $ 为尾的弧）， 这个单链表就称为顶点 $ v_i $ 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点，如下图所示： <img src="/assets/img_11-piKNGkOy.png" alt="img_11.png"></p><p>顶点表结点由顶点域(data)和指向第一条邻接边的指针(firstarc) 构成，边表(邻接表)结点由邻接点域(adjvex)和指向下一条邻接边的指针域(nextarc) 构成。</p><p>无向图的邻接表的实例如下图所示 <img src="/assets/img_12-CVMRyJOm.png" alt="img_12.png"></p><p>有向图的邻接表的实例如下图所示 <img src="/assets/img_13-DDyfJe_T.png" alt="img_13.png"></p><h5 id="代码实现-1" tabindex="-1"><a class="header-anchor" href="#代码实现-1"><span>代码实现</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 边表结点</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">EdgeNode</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> adjvex<span class="token punctuation">;</span>       <span class="token comment">// 该弧所指向的顶点的下标或者位置</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> weight<span class="token punctuation">;</span>       <span class="token comment">// 权值，对于非网图可以不需要</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">EdgeNode</span> next<span class="token punctuation">;</span>    <span class="token comment">// 指向下一个邻接点</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 构造方法</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">EdgeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> adjvex<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>adjvex <span class="token operator">=</span> adjvex<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 顶点表结点</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">VertexNode</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">char</span> data<span class="token punctuation">;</span>        <span class="token comment">// 顶点域，存储顶点信息</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">EdgeNode</span> firstedge<span class="token punctuation">;</span>  <span class="token comment">// 边表头指针</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 构造方法</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">VertexNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>firstedge <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 邻接表表示的图</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdjacencyListGraph</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXVEX</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">// 图中顶点数目的最大值</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">VertexNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> adjList<span class="token punctuation">;</span>           <span class="token comment">// 顶点表数组</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> numVertexes<span class="token punctuation">;</span>                <span class="token comment">// 图中当前顶点数</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> numEdges<span class="token punctuation">;</span>                   <span class="token comment">// 图中当前边数</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 构造方法</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">AdjacencyListGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        adjList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VertexNode</span><span class="token punctuation">[</span><span class="token constant">MAXVEX</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        numVertexes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        numEdges <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>图的邻接表存储方法具有以下特点</p><ol><li>若 $ G $ 为无向图，则所需的存储空间为 $ O(|V| + 2|E|) $；若 $ G $ 为有向图，则所需的存储空间为 $ O(|V| + |E|) $。前者的倍数 2 是由于无向图中，每条边在邻接表中出现了两次。</li><li>对于稀疏图，采用邻接表表示将极大地节省存储空间。</li><li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 $ O(n) $。但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</li><li>在有向图的邻接表表示中，求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上与邻接表存储方式是类似的。</li><li>图的邻接表表示并不唯一，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</li></ol></blockquote><h4 id="_3-十字链表" tabindex="-1"><a class="header-anchor" href="#_3-十字链表"><span>3. 十字链表</span></a></h4><p>十字链表是有向图的一种链式存储结构。 在有向图中，邻接表关心了出度问题，但想了解入度就必须要遍历整个图，反之，逆邻接表解决了入度却不了解出度的情况。因此就是把它们整合在一起。就是<strong>十字链表(Orthogonal List)</strong>。</p><p>我们重新定义顶点表结点结构如下：</p><table><thead><tr><th>data</th><th>firstin</th><th>firstout</th></tr></thead></table><p>其中<code>firstin</code>表示入边表头指针，指向该顶点的入边表中第一个结点，<code>firstout</code>表示出边表头指针，指向该顶点的出边表中的第一个结点。</p><p>重新定义的边表结点结构如下：</p><table><thead><tr><th>tailvex</th><th>headvex</th><th>headlink</th><th>taillink</th></tr></thead></table><p>其中<code>tailvex</code>是指弧起点在顶点表的下标，<code>headvex</code>是指弧终点在顶点表中的下标，<code>headlink</code>是指入边表指针域，指向终点相同的下一条边，<code>taillink</code>是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个<code>weight</code>域来存储权值。</p><p>如下图所示，顶点依然是存入一个一维数组${V_0, V_1, V_2, V_3}$，实线箭头指针的图示完全与的邻接表的结构相同。 就以顶点$V_0$来说，<code>firstout</code>指向的是出边表中的第一个结点$V_3$。所以$V_0$边表结点的<code>headvex = 3</code>，而<code>tailvex</code>就是当前顶点$V_0$的下标0， 由于$V_0$只有一个出边顶点，所以<code>headlink</code>和<code>taillink</code>都是空。 <img src="/assets/img_14-BQayfQh_.png" alt="img_14.png"> 我们重点需要来解释虚线箭头的含义，它其实就是此图的逆邻接表的表示。对于 $ V_0 $ 来说，它有两个顶点 $ V_1 $ 和 $ V_2 $ 的入边。 因此 $ V_0 $ 的 <code>firstin</code> 指向顶点 $ V_1 $ 的边表结点中 <code>headvex</code> 为 0 的结点，如上图右图中的①。 接着由入边结点的 <code>headlink</code> 指向下一个入边顶点 $ V_2 $，如图中的②。对于顶点 $ V_1 $，它有一个入边顶点 $ V_2 $， 所以它的 <code>firstin</code> 指向顶点 $ V_2 $ 的边表结点中 <code>headvex</code> 为 1 的结点，如图中的③。顶点 $ V_2 $ 和 $ V_3 $ 也是同样有一个入边顶点，如图中④和⑤。</p><p>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以 $ V_i $ 为尾的弧，也容易找到以 $ V_i $ 为头的弧，因而容易求得顶点的出度和入度。 而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的。</p><h5 id="代码实现-2" tabindex="-1"><a class="header-anchor" href="#代码实现-2"><span>代码实现</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * 弧结点（Arc Node）</span>
<span class="line"> * 存储有向边的信息</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">ArcNode</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">int</span> tailVex<span class="token punctuation">;</span>    <span class="token comment">// 弧尾顶点下标（起点）</span></span>
<span class="line">    <span class="token keyword">int</span> headVex<span class="token punctuation">;</span>    <span class="token comment">// 弧头顶点下标（终点）</span></span>
<span class="line">    <span class="token class-name">ArcNode</span> hLink<span class="token punctuation">;</span>  <span class="token comment">// 指向同一弧头的下一条弧（入边链）</span></span>
<span class="line">    <span class="token class-name">ArcNode</span> tLink<span class="token punctuation">;</span>  <span class="token comment">// 指向同一弧尾的下一条弧（出边链）</span></span>
<span class="line">    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>     <span class="token comment">// 弧权值（可选）</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">ArcNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> tailVex<span class="token punctuation">,</span> <span class="token keyword">int</span> headVex<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>tailVex <span class="token operator">=</span> tailVex<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>headVex <span class="token operator">=</span> headVex<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>hLink <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>tLink <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * 顶点结点（Vertex Node）</span>
<span class="line"> * 存储顶点信息及其关联的弧</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">VertexNode</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">char</span> data<span class="token punctuation">;</span>          <span class="token comment">// 顶点数据</span></span>
<span class="line">    <span class="token class-name">ArcNode</span> firstIn<span class="token punctuation">;</span>    <span class="token comment">// 指向第一条入弧</span></span>
<span class="line">    <span class="token class-name">ArcNode</span> firstOut<span class="token punctuation">;</span>   <span class="token comment">// 指向第一条出弧</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">VertexNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>firstIn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>firstOut <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token doc-comment comment">/**</span>
<span class="line"> * 十字链表图结构</span>
<span class="line"> */</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrthogonalListGraph</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">VertexNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vertexList<span class="token punctuation">;</span>  <span class="token comment">// 顶点表</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> vertexCount<span class="token punctuation">;</span>          <span class="token comment">// 顶点数</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> arcCount<span class="token punctuation">;</span>            <span class="token comment">// 弧数</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_VERTEX</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 最大顶点数</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">OrthogonalListGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        vertexList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VertexNode</span><span class="token punctuation">[</span><span class="token constant">MAX_VERTEX</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        vertexCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        arcCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-邻接多重表" tabindex="-1"><a class="header-anchor" href="#_4-邻接多重表"><span>4. 邻接多重表</span></a></h4><p>邻接多重表是无向图的另一种链式存储结构。 在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。 比如下图中，若要删除左图的 $ (V_0, V_2) $ 这条边，需要对邻接表结构中右边表的阴影两个结点进行删除操作，显然这是比较烦琐的。 <img src="/assets/img_16-qh16y_jj.png" alt="img_16.png"> 重新定义的边表结点结构如下表所示：</p><table><thead><tr><th>ivex</th><th>ilink</th><th>jvex</th><th>jlink</th></tr></thead><tbody><tr><td>其中 <code>ivex</code> 和 <code>jvex</code> 是与某条边依附的两个顶点在顶点表中下标。<code>ilink</code> 指向依附顶点 <code>ivex</code> 的下一条边，<code>jlink</code> 指向依附顶点 <code>jvex</code> 的下一条边。这就是邻接多重表结构。</td><td></td><td></td><td></td></tr></tbody></table><p>每个顶点也用一个结点表示，它由如下所示的两个域组成：</p><table><thead><tr><th>data</th><th>firstedge</th></tr></thead><tbody><tr><td>其中，<code>data</code> 域存储该顶点的相关信息，<code>firstedge</code> 域指示第一条依附于该顶点的边。</td><td></td></tr></tbody></table><p><img src="/assets/img_17-Bp_e5AA9.png" alt="img_17.png"> 如图，首先连线的①②③④就是将顶点的 <code>firstedge</code> 指向一条边，顶点下标要与 <code>ivex</code> 的值相同。 接着，由于顶点 $ V_0 $ 的 $ (V_0, V_1) $ 边的邻边有 $ (V_0, V_3) $ 和 $ (V_0, V_2) $。因此⑤⑥的连线就是满足指向下一条依附于顶点 $ V_0 $ 的边的目标， 注意 <code>ilink</code> 指向的结点的 <code>jvex</code> 一定要和它本身的 <code>ivex</code> 的值相同。同样的道理，连线⑦就是指 $ (V_1, V_0) $ 这条边，它是相当于顶点 $ V_1 $ 指向 $ (V_1, V_2) $ 边后的下一条。 $ V_2 $ 有三条边依附，所以在③之后就有了⑧⑨。连线④就是顶点 $ V_3 $ 在连线④之后的下一条边。左图一共有5条边，所以右图有10条连线，完全符合预期。</p><blockquote><p>邻接多重表与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。这样对边的操作就方便多了，若要删除左图的 $ (V_0, V_2) $ 这条边，只需要将右图的⑥⑨的链接指向改为 <code>NULL</code> 即可。</p></blockquote><h4 id="_5-边集数组" tabindex="-1"><a class="header-anchor" href="#_5-边集数组"><span>5. 边集数组</span></a></h4><p>边集数组是由两个一维数组构成。一个是存储顶点的信息;另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、 终点下标(end)和权(weight)组成，如下图所示。 显然边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。 <img src="/assets/img_15-CltnhIDT.png" alt="img_15.png"></p><h5 id="代码实现-3" tabindex="-1"><a class="header-anchor" href="#代码实现-3"><span>代码实现</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 边的实体类，存储一条边的起点、终点和权值</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 边的起点下标</span></span>
<span class="line">    <span class="token keyword">int</span> begin<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 边的终点下标</span></span>
<span class="line">    <span class="token keyword">int</span> end<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 边的权值</span></span>
<span class="line">    <span class="token keyword">int</span> weight<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>begin <span class="token operator">=</span> begin<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 边集数组表示的图结构</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EdgeSetArrayGraph</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 存储顶点信息的数组</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vertexArray<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 存储边信息的数组</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeArray<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 图中顶点的数量</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> vertexNum<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 图中边的数量</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> edgeNum<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">EdgeSetArrayGraph</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vertexArray<span class="token punctuation">,</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeArray<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>vertexArray <span class="token operator">=</span> vertexArray<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>edgeArray <span class="token operator">=</span> edgeArray<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>vertexNum <span class="token operator">=</span> vertexArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>edgeNum <span class="token operator">=</span> edgeArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="图的遍历" tabindex="-1"><a class="header-anchor" href="#图的遍历"><span>图的遍历</span></a></h3><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次， 这一过程就叫做图的遍历(Traversing Graph)。通常有两种遍历次序方案:它们是深度优先遍历(Depth First Search)和广度优先遍历(Breadth First Search)。</p><h4 id="_1-dfs算法" tabindex="-1"><a class="header-anchor" href="#_1-dfs算法"><span>1. DFS算法</span></a></h4><p>遵循的搜索策略：尽可能“深”地搜索一个图。首先访问图中某一起始顶点 $ v $，然后由 $ v $ 出发，访问与 $ v $ 邻接且未被访问的任一顶点 $ w_1 $， 再访问与 $ w_1 $ 邻接且未被访问的任一顶点……重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程， 直至图中所有顶点均被访问过为止。</p><h5 id="代码实现-4" tabindex="-1"><a class="header-anchor" href="#代码实现-4"><span>代码实现</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GraphTraversal</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span> <span class="token comment">// 访问标记数组：visited[v]为true表示顶点v已访问</span></span>
<span class="line">    <span class="token comment">// 深度优先遍历（从顶点v出发）</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">MGraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 访问当前顶点</span></span>
<span class="line">        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment">// 标记为已访问</span></span>
<span class="line">        <span class="token comment">// 遍历当前顶点的所有邻接点</span></span>
<span class="line">        <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">firstNeighbor</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 若邻接点w未访问过，递归访问w</span></span>
<span class="line">                <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">            w <span class="token operator">=</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">nextNeighbor</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取w的下一个邻接点</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 遍历整个图（对所有未访问的顶点调用dfs）</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfstraverse</span><span class="token punctuation">(</span><span class="token class-name">MGraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 初始化访问标记数组</span></span>
<span class="line">        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">getVexnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">getVexnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token comment">// 对每个顶点，若未访问则启动DFS</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">getVexnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>DFS属于递归算法，空间复杂度 $O(V)$。</p><p>对于 $ n $ 个顶点 $ e $ 条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要 $ O(V^2) $ 的时间。 而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是 $ O(V + E) $。显然对于多点少边的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。</p><p>深度优先搜索会产生一棵深度优先生成树。 当然，这是有条件的，即对连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林。</p><h4 id="_2-bfs算法" tabindex="-1"><a class="header-anchor" href="#_2-bfs算法"><span>2. BFS算法</span></a></h4><p>广度优先遍历就类似于树的层序遍历。是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。 为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。</p><h5 id="代码实现-5" tabindex="-1"><a class="header-anchor" href="#代码实现-5"><span>代码实现</span></a></h5><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MGraphBFS</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> vexnum<span class="token punctuation">;</span>          <span class="token comment">// 顶点数</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> arcnum<span class="token punctuation">;</span>          <span class="token comment">// 边数</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arcs<span class="token punctuation">;</span>        <span class="token comment">// 邻接矩阵</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vexs<span class="token punctuation">;</span>       <span class="token comment">// 顶点值数组</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span>   <span class="token comment">// 访问标记数组</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 构造方法</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">MGraphBFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> vexnum<span class="token punctuation">,</span> <span class="token keyword">int</span> arcnum<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> vexs<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arcs<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>vexnum <span class="token operator">=</span> vexnum<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>arcnum <span class="token operator">=</span> arcnum<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>vexs <span class="token operator">=</span> vexs<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>arcs <span class="token operator">=</span> arcs<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>vexnum<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 广度优先遍历入口方法</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">BFSTraverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 初始化访问标记数组</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vexnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        </span>
<span class="line">        <span class="token comment">// 使用队列辅助BFS遍历</span></span>
<span class="line">        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        </span>
<span class="line">        <span class="token comment">// 遍历所有顶点</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vexnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token comment">// 访问当前顶点并标记</span></span>
<span class="line">                <span class="token function">visit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 入队</span></span>
<span class="line">                </span>
<span class="line">                <span class="token comment">// BFS核心：处理队列中的顶点</span></span>
<span class="line">                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    <span class="token keyword">int</span> v <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 出队</span></span>
<span class="line">                    </span>
<span class="line">                    <span class="token comment">// 遍历v的所有邻接点</span></span>
<span class="line">                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">firstNeighbor</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> w <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">=</span> <span class="token function">nextNeighbor</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                            <span class="token function">visit</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                            visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">                            queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 邻接点入队</span></span>
<span class="line">                        <span class="token punctuation">}</span></span>
<span class="line">                    <span class="token punctuation">}</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 获取顶点v的第一个邻接点</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">v</span> 顶点下标</span>
<span class="line">     * <span class="token keyword">@return</span> 邻接点下标（无则返回-1）</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">firstNeighbor</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> vexnum<span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>arcs<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 存在边</span></span>
<span class="line">                <span class="token keyword">return</span> w<span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 获取顶点v在邻接点w之后的下一个邻接点</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">v</span> 顶点下标</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">w</span> 当前邻接点下标</span>
<span class="line">     * <span class="token keyword">@return</span> 下一个邻接点下标（无则返回-1）</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">nextNeighbor</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> nextW <span class="token operator">=</span> w <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> nextW <span class="token operator">&lt;</span> vexnum<span class="token punctuation">;</span> nextW<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>arcs<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>nextW<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 存在边</span></span>
<span class="line">                <span class="token keyword">return</span> nextW<span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列 $ Q $，$ n $ 个顶点均需入队一次，在最坏的情况下，空间复杂度为 $ O(V) $。</p><p>采用邻接表存储方式时，每个顶点均需搜索一次（或入队一次），在搜索任一顶点的邻接点时，每条边至少访问一次，算法总的时间复杂度为 $ O(V + E) $。采用邻接矩阵存储方式时，查找每个顶点的邻接点所需的时间为 $ O(V) $，故算法总的时间复杂度为 $ O(V^2) $。</p><blockquote><p>注意：图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同样一个图，基于邻接矩阵的遍历所得到的 DFS 序列和 BFS 序列是唯一的，基于邻接表的遍历所得到的 DFS 序列和 BFS 序列是不唯一的。</p></blockquote><h3 id="图的遍历与图的连通性" tabindex="-1"><a class="header-anchor" href="#图的遍历与图的连通性"><span>图的遍历与图的连通性</span></a></h3><p>图的遍历算法可以用来判断图的连通性。 对于无向图来说，若无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点， 而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。</p><p>故在 <code>BFSTraverse()</code> 或 <code>DFSTraverse()</code> 中添加了第二个 <code>for</code> 循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点。 对于无向图，上述两个函数调用 <code>BFS(G,i)</code> 或 <code>DFS(G,i)</code> 的次数等于该图的连通分量数；而对于有向图则不是这样，因为一个连通的有向图分为强连通的和非强连通的， 它的连通子图也分为强连通分量和非强连通分量，非强连通分量一次调用 <code>BFS(G,i)</code> 或 <code>DFS(G,i)</code> 无法访问到该连通分量的所有顶点。 如下图所示为有向图的非强连通分量。 <img src="data:image/png;base64,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" alt="img_18.png"></p><h4 id="最小生成树" tabindex="-1"><a class="header-anchor" href="#最小生成树"><span>最小生成树</span></a></h4><p>一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的 $ n - 1 $ 条边，若砍去它的一条边，则会使生成树变成非连通图； 若给它增加一条边，则会形成图中的一条回路。对于一个带权连通无向图 $ G = (V, E) $，生成树不同，其中边的权值之和最小的那棵生成树（构造连通网的最小代价生成树）， 称为 $ G $ 的<strong>最小生成树（Minimum-Spanning-Tree, MST）</strong>。</p><p>构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设 $ G = (V, E) $ 是一个带权连通无向图，$ U $ 是顶点集 $ V $ 的一个非空子集。 若 $ (u, v) $ 是一条具有最小权值的边，其中 $ u \in U, v \in V - U $，则必存在一棵包含边 $ (u, v) $ 的最小生成树。 基于该性质的最小生成树算法主要有 Prim 算法和 Kruskal 算法，它们都基于贪心算法的策略。</p><h5 id="普里姆-prim-算法" tabindex="-1"><a class="header-anchor" href="#普里姆-prim-算法"><span>普里姆（Prim）算法</span></a></h5><p>构造最小生成树的过程如下图所示。从一个顶点出发，在保证不形成回路的前提下，每找到并添加一条最短的边，就把当前形成的连通分量当做一个整体或者一个点看待，然后重复“找最短的边并添加”的操作。 <img src="/assets/img_19-CgQSjKMc.png" alt="img_19.png"></p><p>假设 $ G = {V, E} $ 是连通图，其最小生成树 $ T = (U, E_T) $，$ E_T $ 是最小生成树中边的集合。</p><p>初始化：向空树 $ T = (U, E_T) $ 中添加图 $ G = {V, E} $ 的任一顶点 $ u_0 $，使 $ U = {u_0} $，$ E_T = NULL $。</p><p>循环（重复下列操作直至 $ U = V $）：从图 $ G $ 中选择满足 $ {(u, v) | u \in U, v \in V - U} $ 且具有最小权值的边 $ (u, v) $，加入树 $ T $，置 $ U = U \cup {v} $，$ E_T = E_T \cup {(u, v)} $。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrimAlgorithm</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 表示无穷大（用于初始化不连通的边）</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INF</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 普里姆算法构建最小生成树</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">graph</span> 邻接矩阵表示的带权无向图</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">vertexCount</span> 顶点数量</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> vertexCount<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 存储最小生成树的顶点</span></span>
<span class="line">        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>vertexCount<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 存储顶点到最小生成树的最小权值</span></span>
<span class="line">        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>vertexCount<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 标记顶点是否已加入最小生成树</span></span>
<span class="line">        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mstSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>vertexCount<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 初始化所有key值为无穷大</span></span>
<span class="line">        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token constant">INF</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 选择第一个顶点作为起始点，key值设为0</span></span>
<span class="line">        key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 第一个顶点的父节点设为-1（没有父节点）</span></span>
<span class="line">        parent<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 构建最小生成树，需要vertexCount-1条边</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> vertexCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// 选择距离最小生成树最近的顶点</span></span>
<span class="line">            <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token function">minKey</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> mstSet<span class="token punctuation">,</span> vertexCount<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token comment">// 将选择的顶点标记为已加入最小生成树</span></span>
<span class="line">            mstSet<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 更新与u相邻的顶点的key值和父节点</span></span>
<span class="line">            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> vertexCount<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token comment">// 条件：v未加入MST，u和v之间有边，且边的权值小于当前key[v]</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mstSet<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    parent<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span></span>
<span class="line">                    key<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 找到key值最小且未加入MST的顶点</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">minKey</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> key<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mstSet<span class="token punctuation">,</span> <span class="token keyword">int</span> vertexCount<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token constant">INF</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> vertexCount<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mstSet<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                min <span class="token operator">=</span> key<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">                minIndex <span class="token operator">=</span> v<span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> minIndex<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度： $ O(n^2) $</p><h5 id="克鲁斯卡尔-kruskal-算法" tabindex="-1"><a class="header-anchor" href="#克鲁斯卡尔-kruskal-算法"><span>克鲁斯卡尔（Kruskal）算法</span></a></h5><p>Kruskal 算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。 初始时为只有 $ n $ 个顶点而无边的非连通图 $ T = V $，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边， 若该边依附的顶点落在 $ T $ 中不同的连通分量上，则将此边加入 $ T $，否则舍弃此边而选择下一条权值最小的边。以此类推，直至 $ T $ 中所有顶点都在一个连通分量上。 <img src="/assets/img_20-iv23INjc.png" alt="img_20.png"></p><p>我们可以直接就以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。此时我们就用到了图的存储结构中的边集数组结构。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KruskalMST</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * Kruskal算法实现</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">edges</span> 所有边的集合</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">vertexCount</span> 顶点总数</span>
<span class="line">     * <span class="token keyword">@return</span> 最小生成树的边集合</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges<span class="token punctuation">,</span> <span class="token keyword">int</span> vertexCount<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 1. 按边权升序排序</span></span>
<span class="line">        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        </span>
<span class="line">        <span class="token comment">// 2. 初始化并查集</span></span>
<span class="line">        <span class="token class-name">UnionFind</span> uf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>vertexCount<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> mst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存储最小生成树的边</span></span>
<span class="line">        </span>
<span class="line">        <span class="token comment">// 3. 遍历所有边（从小到大）</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">int</span> rootSrc <span class="token operator">=</span> uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">int</span> rootDest <span class="token operator">=</span> uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            </span>
<span class="line">            <span class="token comment">// 4. 若边的两端不在同一集合（不构成环）</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootSrc <span class="token operator">!=</span> rootDest<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                mst<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 加入生成树</span></span>
<span class="line">                uf<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>rootSrc<span class="token punctuation">,</span> rootDest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合并集合</span></span>
<span class="line">                </span>
<span class="line">                <span class="token comment">// 5. 提前终止：已选边数 = 顶点数-1</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span>mst<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> vertexCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">return</span> mst<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此算法的 <code>Find</code> 函数由边数 $ e $ 决定，时间复杂度为 $ O(\log e) $，而外面有一个 <code>for</code> 循环 $ e $ 次。所以克鲁斯卡尔算法的时间复杂度为 $ O(e \log e) $。 对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。</p><h4 id="最短路径" tabindex="-1"><a class="header-anchor" href="#最短路径"><span>最短路径</span></a></h4><p>在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径； 而对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p><h5 id="迪杰斯特拉-dijkstra-算法" tabindex="-1"><a class="header-anchor" href="#迪杰斯特拉-dijkstra-算法"><span>迪杰斯特拉( Dijkstra )算法</span></a></h5><p>用于构建单源点的最短路径，即图中某个点到任何其他点的距离都是最短的。例如，构建地图应用时查找自己的坐标离某个地标的最短距离。可以用于有向图，但是不能存在负权值。</p><p>通俗点说，这个迪杰斯特拉（Dijkstra）算法，它并不是一下子求出了 $ v_0 $ 到 $ v_8 $ 的最短路径，而是一步步求出它们之间顶点的最短路径， 过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果。</p><p>Dijkstra算法设置一个集合 $ S $ 记录已求得的最短路径的顶点。</p><p>在构造的过程中还设置了个辅助数组：</p><p><code>dist[]</code>：记录从源点 $ v_0 $ 到其他各顶点当前的最短路径长度，它的初态为：若从 $ v_0 $ 到 $ v_i $ 有弧，则 <code>dist[i]</code> 为弧上的权值；否则置 <code>dist[i]</code> 为 $ \infty $。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dijkstra</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 迪杰斯特拉算法求单源最短路径</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">graph</span> 图实例</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">src</span> 源点下标</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">int</span> <span class="token class-name">V</span> <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">graph<span class="token punctuation">.</span></span>V</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 存储源点到各顶点的最短距离</span></span>
<span class="line">        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prev <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 存储最短路径的前驱顶点（用于回溯路径）</span></span>
<span class="line">        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化为无穷大</span></span>
<span class="line">        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 前驱初始化为-1（无前驱）</span></span>
<span class="line"></span>
<span class="line">        dist<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 源点到自身距离为0</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 优先队列：按边的权值（距离）升序排列（最小堆）</span></span>
<span class="line">        <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将源点加入队列</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">Edge</span> uEdge <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 取出当前距离最小的顶点</span></span>
<span class="line">            <span class="token keyword">int</span> u <span class="token operator">=</span> uEdge<span class="token punctuation">.</span>dest<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 若队列中取出的距离大于当前记录的最短距离，跳过（避免重复处理）</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;</span> uEdge<span class="token punctuation">.</span>weight<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 遍历u的所有邻接顶点v</span></span>
<span class="line">            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> vEdge <span class="token operator">:</span> graph<span class="token punctuation">.</span>adj<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">int</span> v <span class="token operator">=</span> vEdge<span class="token punctuation">.</span>dest<span class="token punctuation">;</span></span>
<span class="line">                <span class="token keyword">int</span> newDist <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> vEdge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>  <span class="token comment">// 从u到v的新距离</span></span>
<span class="line"></span>
<span class="line">                <span class="token comment">// 若新距离更短，更新dist[v]和前驱，并加入队列</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span>newDist <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> newDist<span class="token punctuation">;</span></span>
<span class="line">                    prev<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span></span>
<span class="line">                    pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> newDist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 输出结果：每个顶点的最短距离和路径</span></span>
<span class="line">        <span class="token function">printResult</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度为 $ O(V^2) $。</p><h5 id="弗洛伊德-floyd-算法" tabindex="-1"><a class="header-anchor" href="#弗洛伊德-floyd-算法"><span>弗洛伊德( Floyd )算法</span></a></h5><p>定义一个 $ n $ 阶方阵序列 $ A^{(-1)}, A^{(0)}, \dots, A^{(n - 1)} $，其中， $A^{(-1)}[i][j] = arcs[i][j]$</p><p>$A^{(k)}[i][j] = Min\left{ A^{(k - 1)}[i][j], A^{(k - 1)}[i][k] + A^{(k - 1)}[k][j] \right}, k = 0, 1, \dots, n - 1$ 式中，$ A^{(0)}[i][j] $ 是从顶点 $ v_i $ 到 $ v_j $、中间顶点的序号不大于 $ k $ 的最短路径的长度。Floyd 算法是一个迭代的过程，每迭代一次，在从 $ v_i $ 到 $ v_j $ 的最短路径上就多考虑了一个顶点；经过 $ n $ 次迭代后，所得到的 $ A^{(n - 1)}[i][j] $ 就是 $ v_i $ 到 $ v_j $ 的最短路径长度，即方阵 $ A^{(n - 1)} $ 中就保存了任意一对顶点之间的最短路径长度。</p><p><img src="/assets/img_21-BYiDV-oo.png" alt="img_21.png"> 上图所示为带权有向图 $ G $ 及其邻接矩阵。算法执行过程的说明如下。</p><ul><li>初始化：方阵 $ A^{(-1)}[i][j] = arcs[i][j] $。</li><li>第一轮：将 $ v_0 $ 作为中间顶点，对于所有顶点对 $ {i, j} $，如果有 $ A^{-1}[i][j] &gt; A^{-1}[i][0] + A^{-1}[0][j] $，则将 $ A^{-1}[i][j] $ 更新为 $ A^{-1}[i][0] + A^{-1}[0][j] $。有 $ A^{-1}[2][1] &gt; A^{-1}[2][0] + A^{-1}[0][1] = 11 $，更新 $ A^{-1}[2][1] = 11 $，更新后的方阵标记为 $ A^0 $。</li><li>第二轮：将 $ v_1 $ 作为中间顶点，继续监测全部顶点对 $ {i, j} $。有 $ A^0[0][2] &gt; A^0[0][1] + A^0[1][2] = 10 $，更新后的方阵标记为 $ A^1 $。</li><li>第三轮：将 $ v_2 $ 作为中间顶点，继续监测全部顶点对 $ {i, j} $。有 $ A^1[1][0] &gt; A^1[1][2] + A^1[2][0] = 9 $，更新后的方阵标记为 $ A^2 $。此时 $ A^2 $ 中保存的就是任意顶点对的最短路径长度。</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FloydWarshall</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INF</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span> <span class="token comment">// 无穷大（表示无直接路径）</span></span>
<span class="line"></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * Floyd算法实现</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">graph</span> 邻接矩阵（graph[i][j]表示顶点i到j的直接距离）</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">floyd</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">int</span> n <span class="token operator">=</span> graph<span class="token punctuation">.</span>length<span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 初始化距离矩阵和路径矩阵</span></span>
<span class="line">        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录路径中i的下一个节点</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 1. 初始化矩阵</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">                next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">INF</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> j<span class="token punctuation">)</span> <span class="token operator">?</span> j <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 2. 动态规划：以k为中间点更新所有路径</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">INF</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 跳过无效路径</span></span>
<span class="line">                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                    <span class="token comment">// 避免整数溢出</span></span>
<span class="line">                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">INF</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">INF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                        <span class="token keyword">int</span> newDist <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">                        <span class="token keyword">if</span> <span class="token punctuation">(</span>newDist <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                            dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> newDist<span class="token punctuation">;</span></span>
<span class="line">                            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 更新路径</span></span>
<span class="line">                        <span class="token punctuation">}</span></span>
<span class="line">                    <span class="token punctuation">}</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 3. 检测负权回路</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;存在负权回路！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度为 $ O(V^3) $。</p><h4 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序"><span>拓扑排序</span></a></h4><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网(Activity On Vertex Network)。</p><p>若用DAG图（有向无环图）表示一个工程，其顶点表示活动，用有向边 $ &lt;V_i, V_j&gt; $ 表示活动 $ V_i $ 必须先于活动 $ V_j $ 进行的这样一种关系。 在AOV网中，活动 $ V_i $ 是活动 $ V_j $ 的直接前驱，活动 $ V_j $ 是活动 $ V_i $ 的直接后继，这种前驱和后继关系具有传递性， 且任何活动 $ V_i $ 不能以它自己作为自己的前驱或后继。</p><p>设 $ G = (V, E) $ 是一个具有 $ n $ 个顶点的有向图，$ V $ 中的顶点序列 $ V_1, V_2, \dots, V_n $，满足若从顶点 $ V_i $ 到 $ V_j $ 有一条路径， 则在顶点序列中顶点 $ V_i $ 必在顶点 $ V_j $ 之前。则我们称这样的顶点序列为一个拓扑序列。</p><p>所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。每个AOV网都有一个或多个拓扑排序序列。</p><p>对一个AOV网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤：</p><ul><li>①从AOV网中选择一个没有前驱的顶点并输出。</li><li>②从网中删除该顶点和所有以它为起点的有向边。</li><li>③重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环(回路)，不是AOV网。</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TopologicalSort</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token doc-comment comment">/**</span>
<span class="line">     * 拓扑排序算法（返回是否成功，存在回路则失败）</span>
<span class="line">     * <span class="token keyword">@param</span> <span class="token parameter">G</span> 图实例</span>
<span class="line">     * <span class="token keyword">@return</span> 排序成功返回true，存在回路返回false</span>
<span class="line">     */</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> indegree <span class="token operator">=</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">computeIndegree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1. 计算所有顶点的入度</span></span>
<span class="line">        <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2. 初始化栈（存储入度为0的顶点）</span></span>
<span class="line">        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 3. 计数：已输出的顶点数</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 步骤1：将所有入度为0的顶点压入栈</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">G</span><span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 步骤2：循环处理栈中的顶点（入度为0的顶点）</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">int</span> u <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 弹出入度为0的顶点</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出该顶点</span></span>
<span class="line">            count<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 遍历顶点u的所有邻接顶点v，更新其入度</span></span>
<span class="line">            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">EdgeNode</span> e <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>adjList<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">                <span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span>adjvex<span class="token punctuation">;</span></span>
<span class="line">                indegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// v的入度减1（因为u已处理）</span></span>
<span class="line">                <span class="token keyword">if</span> <span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 若v的入度变为0，压入栈</span></span>
<span class="line">                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">                <span class="token punctuation">}</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 步骤3：检查是否存在回路（若输出的顶点数少于总顶点数，说明有回路）</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token class-name">G</span><span class="token punctuation">.</span>vexnum<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;图中存在回路，拓扑排序失败！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;拓扑排序成功！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="关键路径" tabindex="-1"><a class="header-anchor" href="#关键路径"><span>关键路径</span></a></h4><p>拓扑排序主要是为解决一个工程能否顺序进行的问题，但有时我们还需要解决工程完成需要的最短时间问题。</p><p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络，简称AOE网。 AOE网和AOV网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE网中的边有权值；而AOV网中的边无权值，仅表示顶点之间的前后关系。</p><p>AOE网具有以下两个性质：</p><ul><li>①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li><li>②只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。</li></ul><p>求关键路径的算法步骤如下：</p><ol><li>从源点出发，令 $ ve(\text{源点}) = 0 $，按拓扑排序求其余顶点的最早发生时间 $ ve() $。</li><li>从汇点出发，令 $ vl(\text{汇点}) = ve(\text{汇点}) $，按逆拓扑排序求其余顶点的最迟发生时间 $ vl() $。</li><li>根据各顶点的 $ ve() $ 值求所有弧的最早开始时间 $ e() $。</li><li>根据各顶点的 $ vl() $ 值求所有弧的最迟开始时间 $ l() $。</li><li>求AOE网中所有活动的差额 $ d() $，找出所有有 $ d() = 0 $ 的活动构成关键路径。</li></ol><p>参考资料：<a href="https://blog.csdn.net/Real_Fool_/article/details/114141377" target="_blank" rel="noopener noreferrer">数据结构：图(Graph)【详解】<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></div></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="xicon-container left meta-item-label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 32 32" class="xicon-icon" style="width:20px;height:20px;font-size:20px;color:;"><path d="M26 4h-4V2h-2v2h-8V2h-2v2H6c-1.1 0-2 .9-2 2v20c0 1.1.9 2 2 2h20c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 22H6V12h20v14zm0-16H6V6h4v2h2V6h8v2h2V6h4v4z" fill="currentColor"></path></svg><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->最近更新 2025/8/13 21:41:44<!--]--></span></span></div></footer><!----><div class="reco-valine-wrapper"><div id="valine"></div></div></div><div class="page-catalog-container"><h5 class="tip">ON THIS PAGE</h5><ul><!--[--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/algorithm/graph.html#图的基本概念" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="图的基本概念"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->图的基本概念<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/algorithm/graph.html#图的基本概念-1" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="图的基本概念"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->图的基本概念<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/algorithm/graph.html#图的存储结构" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="图的存储结构"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->图的存储结构<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/algorithm/graph.html#图的遍历" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="图的遍历"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->图的遍历<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--[--><li class="page-catalog-menu-depth_3"><a aria-current="page" href="/blogs/algorithm/graph.html#图的遍历与图的连通性" class="router-link-active router-link-exact-active link page-catalog-item page-catalog-item" aria-label="图的遍历与图的连通性"><!--[--><!--]--><span class="xicon-container left"><!--[--><!----><!--]--><span class="xicon-content" style="color:;font-size:14px;"><!--[-->图的遍历与图的连通性<!--]--></span></span><!--[--><!--]--></a></li><!--]--><!--]--></ul></div></main><!--]--></div></div><!--[--><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-ByLG9LQz.js" defer></script>
  </body>
</html>
